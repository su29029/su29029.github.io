<!DOCTYPE html>
<html lang="zh-hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"su29029.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux IPC 学习起因专门去学习Linux IPC的缘由是CNSS 2020 Recruit的一道招新题，题目直接给了一个shell，但是获取了shell连上服务器之后，由于flag权限不足，只能通过readflag程序来读取flag，而readflag这个程序需要进行简单的程序交互，通过题目给的shell是无法完成这一操作的，我们需要编写一个交互程序，来自动完成与readflag的交互让其">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux IPC 学习">
<meta property="og:url" content="https://su29029.github.io/2020/12/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="su29029的博客">
<meta property="og:description" content="Linux IPC 学习起因专门去学习Linux IPC的缘由是CNSS 2020 Recruit的一道招新题，题目直接给了一个shell，但是获取了shell连上服务器之后，由于flag权限不足，只能通过readflag程序来读取flag，而readflag这个程序需要进行简单的程序交互，通过题目给的shell是无法完成这一操作的，我们需要编写一个交互程序，来自动完成与readflag的交互让其">
<meta property="og:locale">
<meta property="og:image" content="https://leisure_chn.gitee.io/blog/figure/linux_process/task_status.jpg">
<meta property="article:published_time" content="2020-12-16T03:33:12.000Z">
<meta property="article:modified_time" content="2021-01-06T18:09:14.137Z">
<meta property="article:author" content="su29029">
<meta property="article:tag" content="web安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leisure_chn.gitee.io/blog/figure/linux_process/task_status.jpg">

<link rel="canonical" href="https://su29029.github.io/2020/12/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-hans'
  };
</script>

  <title>Linux IPC 学习 | su29029的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">su29029的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">因为心在那里</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-hans">
    <link itemprop="mainEntityOfPage" href="https://su29029.github.io/2020/12/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="su29029">
      <meta itemprop="description" content="因为心在那里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="su29029的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux IPC 学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-16 11:33:12" itemprop="dateCreated datePublished" datetime="2020-12-16T11:33:12+08:00">2020-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-07 02:09:14" itemprop="dateModified" datetime="2021-01-07T02:09:14+08:00">2021-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
                </span>
            </span>

          
            <span id="/2020/12/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/" class="post-meta-item leancloud_visitors" data-flag-title="Linux IPC 学习" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/12/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>112k字</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:42</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Linux-IPC-学习"><a href="#Linux-IPC-学习" class="headerlink" title="Linux IPC 学习"></a>Linux IPC 学习</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>专门去学习Linux IPC的缘由是CNSS 2020 Recruit的一道招新题，题目直接给了一个shell，但是获取了shell连上服务器之后，由于flag权限不足，只能通过readflag程序来读取flag，而readflag这个程序需要进行简单的程序交互，通过题目给的shell是无法完成这一操作的，我们需要编写一个交互程序，来自动完成与readflag的交互让其输出flag。</p>
<a id="more"></a>

<p>这个题的预期解是通过运行一个perl程序来完成交互，服务器上perl环境已经安装好了。但是这个预期解的局限性也就在于必须得有perl环境才能正常操作，深入思考了预期解的payload，会发现其实整个程序的本质就是两个linux进程之间的通信过程，进程间通信我们也可以通过c或者go等语言，编译成binary直接丢上服务器运行，这样就可以不依赖任何特定的语言环境了。</p>
<h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h3><p>首先简单讲讲进程和线程相关的概念。</p>
<h4 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h4><p>进程：操作系统进行资源分配的基本单位。</p>
<p>线程：操作系统进行调度和执行的基本单位。</p>
<h4 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h4><p>操作系统中主要使用进程控制块（即PCB）来描述进程。Linux中的PCB是<code>task_struct</code>类型结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="comment">// reference: https://www.cs.fsu.edu/~baker/opsys/examples/task_struct.html</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * offsets of these are hardcoded elsewhere - touch with care</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;	<span class="comment">/* per process flags, defined below */</span></span><br><span class="line">	<span class="keyword">int</span> sigpending;</span><br><span class="line">	<span class="keyword">mm_segment_t</span> addr_limit;	<span class="comment">/* thread address space:</span></span><br><span class="line"><span class="comment">					 	0-0xBFFFFFFF for user-thead</span></span><br><span class="line"><span class="comment">						0-0xFFFFFFFF for kernel-thread</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span> *<span class="title">exec_domain</span>;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> need_resched;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lock_depth;		<span class="comment">/* Lock depth */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * offset 32 begins here on 32-bit platforms. We keep</span></span><br><span class="line"><span class="comment"> * all fields in a single cacheline that are needed for</span></span><br><span class="line"><span class="comment"> * the goodness() loop in schedule().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">long</span> counter;</span><br><span class="line">	<span class="keyword">long</span> nice;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> policy;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">int</span> processor;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * cpus_runnable is ~0 if the process is not running on any</span></span><br><span class="line"><span class="comment">	 * CPU. It&#x27;s (1 &lt;&lt; cpu) if it&#x27;s running on a CPU. This mask</span></span><br><span class="line"><span class="comment">	 * is updated under the runqueue lock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * To determine whether a process might run on a CPU, this</span></span><br><span class="line"><span class="comment">	 * mask is AND-ed with cpus_allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpus_runnable, cpus_allowed;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (only the &#x27;next&#x27; pointer fits into the cacheline, but</span></span><br><span class="line"><span class="comment">	 * that&#x27;s just fine.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sleep_time;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_task</span>, *<span class="title">prev_task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">local_pages</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> allocation_order, nr_local_pages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* task state */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line">	<span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line">	<span class="keyword">int</span> pdeath_signal;  <span class="comment">/*  The signal sent when the parent dies  */</span></span><br><span class="line">	<span class="comment">/* ??? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> personality;</span><br><span class="line">	<span class="keyword">int</span> did_exec:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">pid_t</span> pgrp;</span><br><span class="line">	<span class="keyword">pid_t</span> tty_old_pgrp;</span><br><span class="line">	<span class="keyword">pid_t</span> session;</span><br><span class="line">	<span class="keyword">pid_t</span> tgid;</span><br><span class="line">	<span class="comment">/* boolean value for session group leader */</span></span><br><span class="line">	<span class="keyword">int</span> leader;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * pointers to (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">	 * older sibling, respectively.  (p-&gt;father can be replaced with </span></span><br><span class="line"><span class="comment">	 * p-&gt;p_pptr-&gt;pid)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_opptr</span>, *<span class="title">p_pptr</span>, *<span class="title">p_cptr</span>, *<span class="title">p_ysptr</span>, *<span class="title">p_osptr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PID hash table linkage. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash_next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">pidhash_pprev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait_chldexit;	<span class="comment">/* for wait4() */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>		<span class="comment">/* for vfork() */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rt_priority;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> it_real_incr, it_prof_incr, it_virt_incr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">real_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">times</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_time;</span><br><span class="line">	<span class="keyword">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];</span><br><span class="line"><span class="comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line">	<span class="keyword">int</span> swappable:<span class="number">1</span>;</span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">	<span class="keyword">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">	<span class="keyword">int</span> ngroups;</span><br><span class="line">	<span class="keyword">gid_t</span>	groups[NGROUPS];</span><br><span class="line">	<span class="keyword">kernel_cap_t</span>   cap_effective, cap_inheritable, cap_permitted;</span><br><span class="line">	<span class="keyword">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="comment">/* limits */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;</span><br><span class="line">	<span class="keyword">char</span> comm[<span class="number">16</span>];</span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="keyword">int</span> link_count, total_link_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span> <span class="comment">/* NULL if no tty */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> locks; <span class="comment">/* How many file locks are being held */</span></span><br><span class="line"><span class="comment">/* ipc stuff */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">semundo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">semsleeping</span>;</span></span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="comment">/* signal handlers */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> sigmask_lock;	<span class="comment">/* Protects signal and blocked */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sigset_t</span> blocked;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line">	<span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line">	<span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);</span><br><span class="line">	<span class="keyword">void</span> *notifier_data;</span><br><span class="line">	<span class="keyword">sigset_t</span> *notifier_mask;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/* Thread group tracking */</span></span><br><span class="line">   	u32 parent_exec_id;</span><br><span class="line">   	u32 self_exec_id;</span><br><span class="line"><span class="comment">/* Protection of (de-)allocation: mm, files, fs, tty */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> alloc_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* journalling filesystem info */</span></span><br><span class="line">	<span class="keyword">void</span> *journal_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>R, TASK_RUNNING：就绪态或者运行态，进程就绪可以运行，但是不一定正在占有CPU<br>S, TASK_INTERRUPTIBLE：浅度睡眠，等待资源，可以响应信号，一般是进程主动sleep进入的状态<br>D, TASK_UNINTERRUPTIBLE：深度睡眠，等待资源，不响应信号，典型场景是进程获取信号量阻塞<br>Z, TASK_ZOMBIE：僵尸态，进程已退出或者结束，但是父进程还不知道，没有回收时的状态<br>T, TASK_STOPED：停止，调试状态，收到SIGSTOP信号进程挂起</p>
<img src="https://leisure_chn.gitee.io/blog/figure/linux_process/task_status.jpg">

<h4 id="进程的创建与消亡"><a href="#进程的创建与消亡" class="headerlink" title="进程的创建与消亡"></a>进程的创建与消亡</h4><p>(1) system()<br>通过调用shell启动一个新进程</p>
<p>(2) exec()<br>以替换当前进程映像的方式启动一个新进程</p>
<p>(3) fork()<br>以复制当前进程映像的方式启动一个新进程，子进程中fork()返回0，父进程fork()返回为子进程ID。</p>
<p>(4) wait()<br>父进程挂起，等待子进程结束。</p>
<p>(5) 孤儿进程与僵尸进程<br>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程不会浪费资源。<br>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。僵尸进程会浪费系统资源。<br>僵尸进程产生原因：</p>
<ol>
<li><p>子进程结束后向父进程发出SIGCHLD信号，父进程默认忽略了它。</p>
</li>
<li><p>父进程没有调用wait()或waitpid()函数来等待子进程的结束。</p>
</li>
</ol>
<p>避免僵尸进程的方法：</p>
<ol>
<li>父进程调用wait()或者waitpid()等待子进程结束，这样处理父进程一般会阻塞在wait处而不能处理其他事情。</li>
<li>捕捉SIGCHLD信号，并在信号处理函数里面调用wait函数，这样处理可避免1中描述的问题。</li>
<li>fork两次，父进程创建儿子进程，儿子进程再创建一个孙子进程，然后儿子进程自杀，孙子进程成为孤儿进程被init进程收养。</li>
</ol>
<h3 id="进程相关基础操作（c语言）"><a href="#进程相关基础操作（c语言）" class="headerlink" title="进程相关基础操作（c语言）"></a>进程相关基础操作（c语言）</h3><h4 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h4><p>fork()函数用于创建一个进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_process_message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> myprocess_id = getpid();</span><br><span class="line">    <span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="keyword">gid_t</span> ugid = getgid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getpid = %d getuid= %d getgid= %d \n&quot;</span>, myprocess_id, uid, ugid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork: n = %d\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> fpid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( fpid &lt; <span class="number">0</span> ) &#123; <span class="comment">// fork error</span></span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child_proc(%d, ppid=%d): n= %d\n&quot;</span>, getpid(), getppid(), n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent process</span></span><br><span class="line">        n--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent_proc(%d): n= %d\n&quot;</span>,getpid(),n);</span><br><span class="line">    &#125;</span><br><span class="line">    print_process_message();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;quit_proc(%d) ...\n&quot;</span>,getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意fork()函数执行一次返回两次，一次是父进程返回，返回大于0的数（子进程ID），一次是子进程返回，若执行成功返回0。</p>
<h4 id="fork-和-vfork"><a href="#fork-和-vfork" class="headerlink" title="fork() 和 vfork()"></a>fork() 和 vfork()</h4><p>fork创建子进程，把父进程数据空间、堆和栈复制一份；<br>vfork创建子进程，与父进程内存数据共享；<br>但是后来的fork也进行了改变，不是一开始调用fork就复制数据，而是只有在子进程要修改数据的时候，才进行复制，即copy-on-write(COW写时拷贝技术)</p>
<h4 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h4><p><code>pid_t wait(int \*status)</code>等待任意子进程退出，并捕获退出状态<br><code>pid_t waitpid(pid_t pid, int \*status, int options)</code>等待子进程退出，并捕获退出状态</p>
<p>两个函数返回的都是退出的子进程的id。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[],<span class="keyword">char</span> *envp[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> fpid = fork(), pid;</span><br><span class="line">    <span class="keyword">if</span> ( fpid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( fpid == <span class="number">0</span> ) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> stat;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            pid = waitpid(fpid, &amp;stat, WNOHANG); <span class="comment">//stat用于记录子进程的返回结果</span></span><br><span class="line">            <span class="keyword">if</span> ( pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wait child proc ... \n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(stat)) &#123; <span class="comment">//这个函数如果子进程正常退出的话返回真</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child_proc(%d): exit_code :%d\n&quot;</span>, pid, WEXITSTATUS(stat));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序启动了一个子进程，休眠5秒后结束，父进程每1秒轮询一次子进程的状态，若子进程已退出，pid为子进程ID大于0，则退出循环，否则继续等待。</p>
<p>可以使用两种方式来处理子进程的退出，一种是通过signal()函数处理SIGCHLD信号，例如忽略该信号以防止出现僵尸进程，另一种方式就是通过wait()和waitpid()函数来回收子进程以防止出现僵尸进程。</p>
<h4 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h4><p>exec()是一个系统调用，它将以新的进程空间替换现在的进程空间执行程序，进程pid不变。调用exec后，系统会申请一块新的进程空间来存放被调用的程序，然后当前进程会携带pid跳转到新的进程空间，并从main函数开始执行，旧的进程空间被回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv_ch[]=&#123;<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-al&quot;</span>,<span class="string">&quot;/usr/include/linux&quot;</span>,<span class="literal">NULL</span>&#125;; </span><br><span class="line">    <span class="keyword">char</span> *envp_ch[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(<span class="string">&quot;/bin/ls&quot;</span>,argv_ch,envp_ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序通过execve()函数执行<code>/bin/ls</code>程序，并传入参数和环境变量。程序将用新的子程序进程空间替换当前程序的进程空间来执行程序，进程pid不变。</p>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>Linux Daemon进程是运行在后台的一种特殊进程。<br>一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，<strong>所以它是一个由init继承的孤儿进程；</strong><br>守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理；<br>守护进程的名称通常以d结尾，比如sshd,xinetd,crond等</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="system-和popen-函数"><a href="#system-和popen-函数" class="headerlink" title="system()和popen()函数"></a>system()和popen()函数</h4><p>system函数执行一个shell命令，system()函数调用/bin/sh来执行参数指定的命令，/bin/sh一般是一个软连接，指向某个具体的shell，比如bash。</p>
<p>system()函数的调用执行了三步操作：</p>
<ol>
<li>fork一个子进程</li>
<li>在子进程中调用exec函数去执行command</li>
<li>在父进程中调用wait去等待子进程结束；</li>
</ol>
<p><strong>注意：system()并不能获取命令执行的输出结果，只能得到执行的返回值；</strong></p>
<p>popen函数启动另外一个进程去执行一个shell命令行，称调用popen的进程为父进程，由popen启动的进程称为子进程。</p>
<p>popen函数还创建一个管道用于父子进程间通信，父进程要么从管道读信息，要么向管道写信息，至于是读还是写取决于父进程调用popen时传递的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;cmd&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> output[<span class="number">1024</span>+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    FILE *pp = popen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>); <span class="comment">// 指定创建一个只读管道，用于从中读子进程命令执行的输出</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;popen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nread = fread(output, <span class="number">1</span>, <span class="number">1024</span>, pp); <span class="comment">//父进程通过文件指针读取子进程的输出设备。</span></span><br><span class="line">    <span class="keyword">int</span> status = pclose(pp);</span><br><span class="line">    <span class="keyword">if</span>(status &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pclose error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output[nread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;status: %d\n%s&quot;</span>, WEXITSTATUS(status), output);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序通过popen()函数创建子进程执行指定的命令，并创建一个只读管道，用于从中读子进程命令执行的输出。</p>
<h4 id="signal信号"><a href="#signal信号" class="headerlink" title="signal信号"></a>signal信号</h4><p>信号(signal)是一种软中断，信号机制是进程间通信的一种方式，采用异步通信方式。</p>
<p>几个主要的信号：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIGINT(2)</td>
<td>中断（即CTRL + C）</td>
</tr>
<tr>
<td>SIGKILL(9)</td>
<td>kill信号（强杀，进程不能阻止）</td>
</tr>
<tr>
<td>SIGPIPE(13)</td>
<td>管道破损，没有读端的管道写数据,就是那个brokenpipe。<strong>默认杀进程，所以网络编程中要处理这个信号。</strong>（当服务器close一个连接时，根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。）</td>
</tr>
<tr>
<td>SIGTERM(15)</td>
<td>终止信号，这个不是强制的，它可以被捕获和解释（或忽略）的过程。类似于和这个进程商量一下，让它退出。</td>
</tr>
<tr>
<td>SIGCHLD(17)</td>
<td>子进程退出，默认忽略</td>
</tr>
<tr>
<td>SIGSTOP(19)</td>
<td>进程停止，不能被忽略、处理和阻塞</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received signal: %d\n&quot;</span>, signum);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    signal(SIGINT, handle_signal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;running ... \n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序启动后持续监听，直到有任何信号发送给程序，输出信号的值后退出。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="Linux的所有进程间通信方式"><a href="#Linux的所有进程间通信方式" class="headerlink" title="Linux的所有进程间通信方式"></a>Linux的所有进程间通信方式</h4><ol>
<li>管道：在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li>套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
<li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ol>
<p>这里主要详细介绍管道通信和unix域套接字通信。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是一个进程连接数据流到另一个进程的通道，它通常是用作把一个进程的输出通过管道连接到另一个进程的输入。例如我们在shell中输入命令：<code>ls -l | grep string</code>，我们知道ls命令会把当前目录中的文件都列出来，但是它不会直接输出，而是把本来要输出到屏幕上的数据通过管道输出到grep这个进程中，作为grep这个进程的输入，然后这个进程对输入的信息进行筛选，把存在string的信息的字符串（以行为单位）打印在屏幕上。</p>
<h5 id="popen-pclose-函数"><a href="#popen-pclose-函数" class="headerlink" title="popen(), pclose()函数"></a>popen(), pclose()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *open_mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream_to_close)</span></span>;</span><br></pre></td></tr></table></figure>

<p>popen()函数允许一个程序将另一个程序作为新进程来启动，并可以传递数据给它或者通过它接收数据。command是要运行的程序名和相应的参数。open_mode只能是”r”和”w”的其中之一。注意，popen()函数的返回值是一个FILE类型的指针，也就是说我们可以使用stdio I/O库中的文件处理函数来对其进行操作。</p>
<p>如果open_mode是”r”，主调用程序就可以使用被调用程序的输出，通过函数返回的FILE指针使用stdio函数（如fread）来读取程序的输出；如果open_mode是”w”，主调用程序就可以向被调用程序发送数据，即通过stdio函数（如fwrite）向被调用程序写数据，而被调用程序就可以在自己的标准输入中读取这些数据。</p>
<p>pclose()函数用于关闭由popen创建出的关联文件流。pclose()只在popen启动的进程结束后才返回，如果调用pclose()时被调用进程仍在运行，pclose()调用将等待该进程结束。它返回关闭的文件流所在进程的退出码。</p>
<p>管道默认是阻塞模式的，通过<code>fcntl(fd, F_SETFL, flags | O_NONBLOCK)</code>可以设置非阻塞的管道</p>
<p>我们将<code>ls -l | grep a</code>命令使用程序实现一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *read_fp = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *write_fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFSIZ + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> chars_read = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 打开ls和grep进程</span></span><br><span class="line">    read_fp = popen(<span class="string">&quot;ls -l&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    write_fp = popen(<span class="string">&quot;grep a&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (read_fp &amp;&amp; write_fp) &#123;</span><br><span class="line">        <span class="comment">// 读取一个数据块</span></span><br><span class="line">        chars_read = fread(buffer, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), BUFSIZ, read_fp);</span><br><span class="line">        <span class="keyword">while</span> (chars_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[chars_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 把数据写入grep进程</span></span><br><span class="line">            fwrite(buffer, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), chars_read, write_fp);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 还有数据可读，循环读取数据，直到读完所有数据</span></span><br><span class="line">            chars_read = fread(buffer, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), BUFSIZ, read_fp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pclose(read_fp);</span><br><span class="line">        pclose(write_fp);</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="popen-的实现方式和优缺点："><a href="#popen-的实现方式和优缺点：" class="headerlink" title="popen()的实现方式和优缺点："></a>popen()的实现方式和优缺点：</h5><p>当请求popen()调用运行一个程序时，它首先启动shell，即系统中的sh命令，然后将command字符串作为一个参数传递给它。</p>
<p>这样就带来了一个优点和一个缺点。优点是：在Linux中所有的参数扩展都是由shell来完成的。所以在启动程序（command中的命令程序）之前先启动shell来分析命令字符串，也就可以使各种shell扩展（如通配符）在程序启动之前就全部完成，这样我们就可以通过popen()启动非常复杂的shell命令。</p>
<p>而它的缺点就是：对于每个popen()调用，不仅要启动一个被请求的程序，还要启动一个shell，即每一个popen()调用将启动两个进程，从效率和资源的角度看，popen()函数的调用比正常方式要慢一些。</p>
<p>另外popen()函数还有一个缺点，每次打开的一个进程只能创建一个读或者写的管道，也就是说我们不能实现与子进程的完全全双工交互，实现这个功能我们就需要使用pipe()函数。</p>
<h5 id="pipe-函数"><a href="#pipe-函数" class="headerlink" title="pipe()函数"></a>pipe()函数</h5><p>pipe()函数是一个底层的调用，与popen()函数不同的是，它在两个进程之间传递数据不需要启动一个shell来解释请求命令，同时它还提供对读写数据的更多的控制。</p>
<p>pipe()函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> file_descriptor[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到pipe()函数的定义非常特别，该函数在数组中包含两个新的文件描述符后返回0，如果返回返回-1，并设置errno()来说明失败原因。数组中的两个文件描述符以一种特殊的方式连接起来，数据基于先进先出的原则，写到file_descriptor[1]的所有数据都可以从file_descriptor[0]读回来。由于数据基于先进先出的原则，所以读取的数据和写入的数据是一致的。</p>
<p>我们可以使用pipe()函数实现匿名管道通信。</p>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><p>一个简单的匿名管道实现父子进程通信的实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s parent_sendmsg child_sendmsg\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipes[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipes) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span>) &#123; <span class="comment">// child</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nbuf;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, argv[<span class="number">1</span>]);</span><br><span class="line">        write(pipes[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里sleep是为了让子进程有时间把管道中的数据读走，不然数据就会被底下的父进程的read读走</span></span><br><span class="line">        <span class="comment">// 因为实质上内核中只有一个管道缓冲区，是父进程创建的，只不过子进程同时拥有了它的引用</span></span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">        </span><br><span class="line">        nbuf = read(pipes[<span class="number">0</span>], buf, BUFSIZ);</span><br><span class="line">        buf[nbuf] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent_proc(%d) recv_from_child: %s\n&quot;</span>, getpid(), buf);</span><br><span class="line"></span><br><span class="line">        close(pipes[<span class="number">0</span>]);</span><br><span class="line">        close(pipes[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123; <span class="comment">// parent</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nbuf = read(pipes[<span class="number">0</span>], buf, BUFSIZ);</span><br><span class="line">        buf[nbuf] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child_proc(%d) recv_from_parent: %s\n&quot;</span>, getpid(), buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(buf, argv[<span class="number">2</span>]);</span><br><span class="line">        write(pipes[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">        close(pipes[<span class="number">0</span>]);</span><br><span class="line">        close(pipes[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际中为了实现双向通信，应该准备两根管道，一根负责从父进程往子进程写数据（同时子进程从这里读取数据），一根负责从子进程往父进程写数据（父进程也从这里读数据）。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ    0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE   1  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doubleInteract</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmdstring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sendStr = <span class="string">&quot;y\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span>   pipeR[<span class="number">2</span>];      <span class="comment">// 父读子写</span></span><br><span class="line">    <span class="keyword">int</span>   pipeW[<span class="number">2</span>];   <span class="comment">// 父写子读</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化管道*/</span>  </span><br><span class="line">    pipe(pipeR);  </span><br><span class="line">    pipe(pipeW);  </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;     <span class="comment">/* parent process */</span></span><br><span class="line">    	close(pipeW[READ]);</span><br><span class="line">        close(pipeR[WRITE]);</span><br><span class="line">        </span><br><span class="line">        read(pipeR[READ], buf, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child:%s&quot;</span>, buf);  <span class="comment">// child: &#x27;do you want flag?(y/n)&#x27;</span></span><br><span class="line"></span><br><span class="line">        write(pipeW[WRITE], sendStr, <span class="built_in">strlen</span>(sendStr)+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent:%s&quot;</span>, sendStr);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,len);</span><br><span class="line">        read(pipeR[READ], buf, len);  <span class="comment">// here is the flag! flag&#123;xxxxxx&#125;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child:%s&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        close(pipeW[WRITE]);</span><br><span class="line">        close(pipeR[READ]);</span><br><span class="line">        waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">/* child process, 关闭写管道的写端，读管道的读端,与父进程正好相对 */</span></span><br><span class="line">        close(pipeW[WRITE]);  </span><br><span class="line">        close(pipeR[READ]);     </span><br><span class="line">        <span class="comment">//重定向子进程的标准输入，标准输出到管道端</span></span><br><span class="line">        <span class="keyword">if</span> (pipeW[READ] != STDOUT_FILENO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dup2(pipeW[READ], STDIN_FILENO) != STDIN_FILENO)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            close(pipeW[READ]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipeR[WRITE] != STDOUT_FILENO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dup2(pipeR[WRITE], STDOUT_FILENO) != STDOUT_FILENO)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            close(pipeR[WRITE]);</span><br><span class="line">        &#125;</span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdstring, (<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doubleInteract(<span class="string">&quot;/readflag&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个简化版的readflag，需要向程序中输入y才能读取到flag，这里可以采用匿名管道的方式，创建两个管道，一个管道读，一个管道写，实现父子进程的双向交互，从而成功获取flag。</p>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><h5 id="命名管道的定义"><a href="#命名管道的定义" class="headerlink" title="命名管道的定义"></a>命名管道的定义</h5><p>命名管道也被称为FIFO文件，它是一种特殊类型的文件，它在文件系统中以文件名的形式存在，但是它的行为却和之前所讲的没有名字的管道（匿名管道）类似。</p>
<p>由于Linux中所有的事物都可被视为文件，所以对命名管道的使用也就变得与文件操作非常的统一，也使它的使用非常方便，同时我们也可以像平常的文件名一样在命令中使用。</p>
<h5 id="创建命名管道"><a href="#创建命名管道" class="headerlink" title="创建命名管道"></a>创建命名管道</h5><p>我们可以使用两下函数之一来创建一个命名管道，他们的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// recommand</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mknod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">mode_t</span> mode | S_IFIFO, (<span class="keyword">dev_t</span>)<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数都能创建一个FIFO文件，注意是创建一个真实存在于文件系统中的文件，filename指定了文件名，而mode则指定了文件的读写权限。</p>
<p>注：mknod是比较老的函数，而使用mkfifo函数更加简单和规范，所以在可能的情况下，尽量使用mkfifo而不是mknod。</p>
<p>举个例子，通过命名管道完成文件数据的发送和收取。</p>
<p>write_data.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fifo_name = <span class="string">&quot;/tmp/tmp_fifo&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> data_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> open_mode = O_WRONLY;</span><br><span class="line">    <span class="keyword">int</span> bytes_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[PIPE_BUF + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (access(fifo_name, F_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 管道文件不存在</span></span><br><span class="line">        <span class="comment">// 创建命名管道</span></span><br><span class="line">        res = mkfifo(fifo_name, <span class="number">0777</span>);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create fifo %s\n&quot;</span>, fifo_name);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process %d opening FIFO O_WRONLY\n&quot;</span>, getpid());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以只写阻塞方式打开FIFO文件，以只读方式打开数据文件</span></span><br><span class="line">    pipe_fd = open(fifo_name, open_mode);</span><br><span class="line">    data_fd = open(<span class="string">&quot;/a.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process %d result %d\n&quot;</span>, getpid(), pipe_fd);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pipe_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 向数据文件读取数据</span></span><br><span class="line">        bytes_read = read(data_fd, buffer, PIPE_BUF);</span><br><span class="line">        buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (bytes_read &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 向FIFO文件写数据</span></span><br><span class="line">            res = write(pipe_fd, buffer, bytes_read);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Write error on pipe\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 累加写的字节数，并继续读取数据</span></span><br><span class="line">            bytes_sent += res;</span><br><span class="line">            bytes_read = read(data_fd, buffer, PIPE_BUF);</span><br><span class="line">            buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fd);</span><br><span class="line">        close(data_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process %d finished\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read_data.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fifo_name = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> data_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> open_mode = O_RDONLY;</span><br><span class="line">    <span class="keyword">char</span> buffer[PIPE_BUF + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bytes_write = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 清空缓冲数组</span></span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process %d opening FIFO O_RDONLY\n&quot;</span>, getpid());</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 以只读阻塞方式打开管道文件，注意与fifowrite.c文件中的FIFO同名</span></span><br><span class="line">    pipe_fd = open(fifo_name, open_mode);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 以只写方式创建保存数据的文件</span></span><br><span class="line">    data_fd = open(<span class="string">&quot;/recvfromfifo.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process %d result %d\n&quot;</span>, getpid(), pipe_fd);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pipe_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 读取FIFO中的数据，并把它保存在文件DataFormFIFO.txt文件中</span></span><br><span class="line">            res = read(pipe_fd, buffer, PIPE_BUF);</span><br><span class="line">            bytes_write = write(data_fd, buffer, res);</span><br><span class="line">            bytes_read += res;</span><br><span class="line">        &#125; <span class="keyword">while</span> (res &gt; <span class="number">0</span>);</span><br><span class="line">        close(pipe_fd);</span><br><span class="line">        close(data_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process %d finished, %d bytes read\n&quot;</span>, getpid(), bytes_read);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名管道相比于匿名管道的优点是可以实现两个完全不相干的进程之间的通信，只需要同时去访问一个管道即可，无需是父子进程关系。</p>
<h4 id="Unix-Domain-Socket"><a href="#Unix-Domain-Socket" class="headerlink" title="Unix Domain Socket"></a>Unix Domain Socket</h4><p>socket原本是为了网络通讯设计的，但是后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。<br>虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：</p>
<ol>
<li>不需要经过网络协议栈；</li>
<li>不需要打包拆包；</li>
<li>不需要计算校验和；</li>
<li>不需要维护序号和应答；</li>
</ol>
<p>这是因为IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。</p>
<p>UNIX Domain Socket也提供面向流和面向数据报两种API接口，类似TCP和UDP，但是面向数据报的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。</p>
<p>使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_STREAM或SOCK_DGRAM，protocol参数仍然指定为0即可。</p>
<p>UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体<code>sockaddr_un</code>表示。</p>
<p>网络编程的socket地址是IP地址加端口号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已经存在，则bind()错误返回。</p>
<p>server.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_PATH <span class="meta-string">&quot;/run/echo.sock&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    signal(SIGINT, handle_signal);</span><br><span class="line">    signal(SIGHUP, handle_signal);</span><br><span class="line">    signal(SIGTERM, handle_signal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((listenfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, SOCK_PATH);</span><br><span class="line"></span><br><span class="line">    unlink(SOCK_PATH);</span><br><span class="line">    <span class="keyword">if</span>(bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123; <span class="comment">//因为这里要在/var/目录下创建一个临时文件，这个程序需要sudo运行</span></span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    chmod(SOCK_PATH, <span class="number">00640</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(listenfd, SOMAXCONN) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> connfd, nbuf;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">if</span>((connfd = accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nbuf = recv(connfd, buf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        buf[nbuf] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new msg: \&quot;%s\&quot;\n&quot;</span>, buf);</span><br><span class="line">        send(connfd, buf, nbuf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(signo == SIGINT)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;received signal: SIGINT(%d)\n&quot;</span>, signo);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGHUP)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;received signal: SIGHUP(%d)\n&quot;</span>, signo);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGTERM)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;received signal: SIGTERM(%d)\n&quot;</span>, signo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listenfd);</span><br><span class="line">    unlink(SOCK_PATH);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_PATH <span class="meta-string">&quot;/run/echo.sock&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s msg\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, SOCK_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> nbuf;</span><br><span class="line"></span><br><span class="line">    nbuf = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    send(sockfd, argv[<span class="number">1</span>], nbuf, <span class="number">0</span>);</span><br><span class="line">    nbuf = recv(sockfd, buf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    buf[nbuf] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;echo msg: \&quot;%s\&quot;\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序实现了通过unix domain socket的client-server 数据传输，就像是通过/var/echo.sock这个文件传输数据。有点类似于命名管道，但是Unix Domain Socket的使用更加广泛。例如wsl2与windows主机的通信，nginx与django进程的通信都是采用unix domain socket来完成。</p>
<h3 id="原题目采用IPC的思路完成最终payload"><a href="#原题目采用IPC的思路完成最终payload" class="headerlink" title="原题目采用IPC的思路完成最终payload"></a>原题目采用IPC的思路完成最终payload</h3><p>由于c语言实现两个进程的多次连续交互存在一些复杂性，这里采用封装更完善，效率更高且更加安全的go语言完成payload编写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd_getflag := exec.Command(<span class="string">&quot;/readflag&quot;</span>)</span><br><span class="line">	getflag_stdin_pipe, getflag_stdin_pipe_error := cmd_getflag.StdinPipe()</span><br><span class="line">	getflag_stdout_pipe, getflag_stdout_pipe_error := cmd_getflag.StdoutPipe()</span><br><span class="line">	<span class="keyword">if</span> getflag_stdin_pipe_error != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Open getflag stdin pipe error:&quot;</span>, getflag_stdin_pipe_error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> getflag_stdout_pipe_error != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Open getflag stdout pipe error:&quot;</span>, getflag_stdout_pipe_error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> getflag_start_error := cmd_getflag.Start(); getflag_start_error != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Run getflag error:&quot;</span>, getflag_start_error)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get the output of getflag</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">300</span>)</span><br><span class="line">	n, _ := getflag_stdout_pipe.Read(buf)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">	getflag_stdin_pipe.Write([]<span class="keyword">byte</span>(<span class="string">&quot;y\n&quot;</span>))</span><br><span class="line">	n, _ = getflag_stdout_pipe.Read(buf)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">	getflag_stdin_pipe.Write([]<span class="keyword">byte</span>(<span class="string">&quot;2\n&quot;</span>))</span><br><span class="line">	n, _ = getflag_stdout_pipe.Read(buf)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(buf[n<span class="number">-16</span> : n]))</span><br><span class="line">	buf1 := <span class="keyword">string</span>(buf[n<span class="number">-16</span> : n<span class="number">-9</span>])</span><br><span class="line">	buf2 := <span class="keyword">string</span>(buf[n<span class="number">-8</span> : n<span class="number">-1</span>])</span><br><span class="line">	a1, _ := strconv.Atoi(buf1)</span><br><span class="line">	a2, _ := strconv.Atoi(buf2)</span><br><span class="line">	res := strconv.Itoa(a1 + a2)</span><br><span class="line">	getflag_stdin_pipe.Write([]<span class="keyword">byte</span>(res + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">	n, _ = getflag_stdout_pipe.Read(buf)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就可以不依赖于特定语言环境完成题目要求。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/web%E5%AE%89%E5%85%A8/" rel="tag"># web安全</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/28/CNSS%20Recruit%202020%20Web%20WriteUp/" rel="prev" title="CNSS Recruit 2020 WriteUp">
      <i class="fa fa-chevron-left"></i> CNSS Recruit 2020 WriteUp
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/02/20210302%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="next" title="20210302学习记录">
      20210302学习记录 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-IPC-%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">Linux IPC 学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B7%E5%9B%A0"><span class="nav-number">1.1.</span> <span class="nav-text">起因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">进程&#x2F;线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程与线程的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">进程的描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.3.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%B6%88%E4%BA%A1"><span class="nav-number">1.2.4.</span> <span class="nav-text">进程的创建与消亡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">进程相关基础操作（c语言）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fork-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">fork()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork-%E5%92%8C-vfork"><span class="nav-number">1.3.2.</span> <span class="nav-text">fork() 和 vfork()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait%E5%92%8Cwaitpid%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">wait和waitpid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">exec系列函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.3.5.</span> <span class="nav-text">守护进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#system-%E5%92%8Cpopen-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.</span> <span class="nav-text">system()和popen()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#signal%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.3.7.</span> <span class="nav-text">signal信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.4.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E7%9A%84%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">Linux的所有进程间通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">1.4.2.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#popen-pclose-%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">popen(), pclose()函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#popen-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">popen()的实现方式和优缺点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pipe-%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">pipe()函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.4.3.</span> <span class="nav-text">匿名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.4.4.</span> <span class="nav-text">命名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">命名管道的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">创建命名管道</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unix-Domain-Socket"><span class="nav-number">1.4.5.</span> <span class="nav-text">Unix Domain Socket</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E9%A2%98%E7%9B%AE%E9%87%87%E7%94%A8IPC%E7%9A%84%E6%80%9D%E8%B7%AF%E5%AE%8C%E6%88%90%E6%9C%80%E7%BB%88payload"><span class="nav-number">1.5.</span> <span class="nav-text">原题目采用IPC的思路完成最终payload</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="su29029"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">su29029</p>
  <div class="site-description" itemprop="description">因为心在那里</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/su29029" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;su29029" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:suyouqi29029@gmail.com" title="E-Mail → mailto:suyouqi29029@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">su29029</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">NaN:aN</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'avgOqaNA0MUU2UDrqoigHt2x-gzGzoHsz',
      appKey     : 'h482kh5MdsMAOaHP6IhmXaGV',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
