<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://su29029.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://su29029.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-使用C语言模拟js前后端交互" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/28/%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Fjs%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/" class="article-date">
  <time datetime="2020-08-28T02:31:36.000Z" itemprop="datePublished">2020-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E8%AF%AD%E8%A8%80/">c语言</a>►<a class="article-category-link" href="/categories/web/">web</a>►<a class="article-category-link" href="/categories/web/web%E5%BC%80%E5%8F%91/">web开发</a>►<a class="article-category-link" href="/categories/web/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/28/%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Fjs%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/">使用C语言模拟js前后端交互</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近一个月复习了初中学习的C语言，刚好学校C语言要做一个期末设计的作业，作为一个web开发者总想着在自己的代码里加一点跟服务器有关的东西，那么，不如用C语言实现一波js的前后端交互吧。   </p>
<h2 id="0x01-首先我们来看一下js的前后端交互是如何完成的"><a href="#0x01-首先我们来看一下js的前后端交互是如何完成的" class="headerlink" title="0x01 首先我们来看一下js的前后端交互是如何完成的"></a>0x01 首先我们来看一下js的前后端交互是如何完成的</h2><p>我们举一个比较简单的例子，来看看js的前后端交互是如何完成的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postAjax</span>(<span class="params">url, data, success</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&#x27;POST&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">            success(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&#x27;X-Requested-With&#x27;</span>, <span class="string">&#x27;XMLHttpRequest&#x27;</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line">postAjax(<span class="string">&quot;http://example.com&quot;</span>, <span class="string">&quot;a=1&amp;b=2&quot;</span>, success);</span><br></pre></td></tr></table></figure>

<p>上面这段代码使用ES5标准原生发送了Ajax Post请求，本质上这是一个http请求。<br>我们主要看第11行，<code>xhr.send(data);</code>这一行代码的作用是将构造好的http请求发送到example.com。整个发送过程是完全封装的，XMLHttpRequest对象的send方法帮助我们完成了整个发送过程，不需要我们自己实现。但是如果是C语言，封装程度比较低，我们就需要自己完成一些请求的发送过程了。</p>
<h2 id="0x02-一个请求的发送过程中都会发生什么"><a href="#0x02-一个请求的发送过程中都会发生什么" class="headerlink" title="0x02 一个请求的发送过程中都会发生什么"></a>0x02 一个请求的发送过程中都会发生什么</h2><p>我们大致分析一下请求的发送过程都会经历那些步骤：<br>1.解析URL<br>2.DNS查询<br>3.封包<br>4.发送请求<br>5.服务器请求处理<br>那么也就说明我们的<code>xhr.send(data);</code>这一行代码完成了请求发送过程的前四步。<br>(关于请求发送过程详见我的另一篇文章<a href="https://su29029.github.io/2019/10/20/%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5www.baidu.com%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E-%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.html">https://su29029.github.io/2019/10/20/当在浏览器中输入www.baidu.com并按下回车后-都发生了什么.html</a>)</p>
<h2 id="0x03-借助套接字完成前台与服务器的链接"><a href="#0x03-借助套接字完成前台与服务器的链接" class="headerlink" title="0x03 借助套接字完成前台与服务器的链接"></a>0x03 借助套接字完成前台与服务器的链接</h2><p>这里我们省去解析URL和DNS查询的过程，直接向某一ip地址发送请求。<br>使用套接字完成服务器端构建一共需要8步：创建套接字，设置套接字地址结构，绑定套接字，设置监听，接收请求，获取请求内容，响应客户端请求，关闭套接字。<br>这里我们只简略的讲述每一步的过程，这其中每一步的操作都非常复杂，单独出来都能写一篇很长的文章，所以这里只简要介绍，想要深入了解C语言 UNIX 套接字编程，可以阅读《UNIX网络编程》一书。</p>
<h4 id="第一步-创建套接字"><a href="#第一步-创建套接字" class="headerlink" title="第一步 创建套接字"></a>第一步 创建套接字</h4><p>函数原型:<code>int socket(int family,int type,int protocol);</code><br>其中：<br>family: family指的是协议簇，可选的有AF_INET,PF_INET,AF_INET6,PF_INET6 前两个代表使用ipv4协议，后两个代表使用ipv6协议。还有些不常使用的AF_LOCAL,AF_ROUTE,AF_KEY等。<br>type: type代表使用的套接字类型，可选的有SOCK_STREAM(字节流套接字)，SOCK_DGRAM(数据报套接字)，SOCK_SEQPACKET(有序分组套接字)，SOCK_RAW(原始套接字)。<br>protocol: protocol指传输层协议类型，可选的有IPPROTO_TCP(TCP协议)，IPPROTO_UDP(UDP协议)，IPPROTO_SCTP(SCTP协议)。  </p>
<p><strong>注意：</strong>socket函数的三个参数不能随意组合，常用的组合如下：<br>SOCK_STREAM+AF_INET/AF_INET6 –&gt; TCP/SCTP协议   (最常用)<br>SOCK_DGRAM+AF_INET/AF_INET6 –&gt; UDP协议<br>SOCK_SEQPACKET+AF_INET/AF_INET6 –&gt; SCTP协议  </p>
<p>函数成功执行返回非负描述符，出错返回-1。  </p>
<h4 id="第二步-设置套接字地址结构"><a href="#第二步-设置套接字地址结构" class="headerlink" title="第二步 设置套接字地址结构"></a>第二步 设置套接字地址结构</h4><p>结构原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet&#x2F;in.h&gt;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    short            sin_family;</span><br><span class="line">    unsigned short   sin_port;</span><br><span class="line">    struct in_addr   sin_addr;</span><br><span class="line">    char             sin_zero[8];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    unsigned long s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里sin_family指的是协议类型，sin_port指端口，sin_addr.s_addr指远程ip地址。我们举个例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in saddr;  &#x2F;&#x2F;定义一个套接字地址结构</span><br><span class="line">memset(&amp;saddr,0,sizeof(saddr));  &#x2F;&#x2F;这里也可使用bzero() [bzero(&amp;saddr,sizeof(saddr))]</span><br><span class="line">saddr.sin_family &#x3D; AF_INET;  &#x2F;&#x2F;指定ipv4协议簇</span><br><span class="line">saddr.sin_port &#x3D; htons(PORT);  &#x2F;&#x2F;端口   htons()作用是将主机字节序转化为网络字节序</span><br><span class="line">saddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);  &#x2F;&#x2F;允许的ip地址 INADDR_ANY 即任意地址</span><br></pre></td></tr></table></figure>
<p>以上代码即设置了一个服务器端的套接字地址结构。</p>
<h4 id="第三步-绑定套接字"><a href="#第三步-绑定套接字" class="headerlink" title="第三步 绑定套接字"></a>第三步 绑定套接字</h4><p>函数原型：<code>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code><br>sockfd: 套接字描述符<br>addr: 套接字地址结构<br>addrlen: 地址结构长度<br>函数的作用是把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32位的ipv4地址或128位的ipv6地址与16位的TCP或UDP端口号的组合。<br>调用bind函数可以选择指定IP或端口号，可以都指定，也可以都不指定。指定或不指定(上一步设置套接字地址结构的时候选择是否指定sin_port和sin_addr.s_addr)的预期结果如下:  </p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th>端口</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>通配地址</td>
<td>0</td>
<td>内核选择IP地址和端口</td>
</tr>
<tr>
<td>通配地址</td>
<td>非0</td>
<td>内核选择IP地址，进程指定端口</td>
</tr>
<tr>
<td>本地IP地址</td>
<td>0</td>
<td>进程指定IP地址，内核选择端口</td>
</tr>
<tr>
<td>本地IP地址</td>
<td>非0</td>
<td>进程指定IP地址和端口</td>
</tr>
</tbody></table>
<h4 id="第四步-设置监听"><a href="#第四步-设置监听" class="headerlink" title="第四步 设置监听"></a>第四步 设置监听</h4><p>函数原型：<code>int listen(int sockfd,int backlog);</code><br>sockfd: 套接字描述符<br>backlog: 允许的最大连接数量<br>这个函数有两个作用：①将我们创建的主动套接字转换为被动套接字，以接收客户端请求；②规定内核应该为响应套接字排队的最大连接个数。  </p>
<h4 id="第五步-接收请求"><a href="#第五步-接收请求" class="headerlink" title="第五步 接收请求"></a>第五步 接收请求</h4><p>函数原型：<code>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);</code><br>sockfd:服务器端套接字描述符<br>cliaddr 和 addrlen 用来返回已连接的对端进程(客户端)的协议地址。<br>如果accept成功，函数返回一个全新描述符，代表与所返回客户的TCP连接。  </p>
<h4 id="第六步-接收客户端请求内容"><a href="#第六步-接收客户端请求内容" class="headerlink" title="第六步 接收客户端请求内容"></a>第六步 接收客户端请求内容</h4><p>函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">ssize_t readv(int fd, const struct iovec *iov, int iovcnt);</span><br><span class="line"></span><br><span class="line">ssize_t recv(int sockfd, void* buf, size_t len, int flags);</span><br><span class="line"></span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure>
<p>这里只分析recv函数，其他函数的具体用法和注意事项自行谷歌。(篇幅限制内容太多)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recv(int sockfd,void* buf,size_t len,int flags);</span><br></pre></td></tr></table></figure>
<p>这个函数用于获取客户端发送的数据，并存入buf中。<br>sockfd:这里需要填写的是客户端套接字描述符<br>buf:客户端发来的数据将存入buf中<br>len:读取数据的长度<br>flags:接收参数，可能的取值如下:</p>
<table>
<thead>
<tr>
<th>flags</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_DONTROUTE</td>
<td>绕过路由表查找</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>本次操作非阻塞</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>发送或接收带外数据</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>窥看外来消息</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>等待所有数据</td>
</tr>
</tbody></table>
<h4 id="第七步-响应客户端请求"><a href="#第七步-响应客户端请求" class="headerlink" title="第七步 响应客户端请求"></a>第七步 响应客户端请求</h4><p>函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">ssize_t writev(int fildes, const struct iovec *iov, int iovcnt);</span><br><span class="line"></span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</span><br><span class="line">                      const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure>
<p>这里只分析send函数，其他函数的具体用法和注意事项自行谷歌。(篇幅限制内容太多)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>
<p>这个函数用于将buf中的数据传回客户端。<br>sockfd: 客户端套接字描述符<br>buf: 欲传回客户端的数据<br>len: 传回数据的长度<br>flags: 发送参数，可能的取值同recv()  </p>
<h4 id="第八步-关闭套接字"><a href="#第八步-关闭套接字" class="headerlink" title="第八步 关闭套接字"></a>第八步 关闭套接字</h4><p>函数原型：<code>int close(int fd);</code><br>这个函数用来关闭套接字，并终止TCP连接。  </p>
<h2 id="0x04-我们来写一个完整的服务器端代码"><a href="#0x04-我们来写一个完整的服务器端代码" class="headerlink" title="0x04 我们来写一个完整的服务器端代码"></a>0x04 我们来写一个完整的服务器端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet&#x2F;in.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;strings.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define BACKLOG	5		&#x2F;&#x2F;允许的连接队列长度</span><br><span class="line">#define PORT	 7546	&#x2F;&#x2F;连接端口</span><br><span class="line">#define RECVBUFF 1048576   &#x2F;&#x2F;接收缓冲区长度</span><br><span class="line">#define SENDBUFF 1048576   &#x2F;&#x2F;发送缓冲区长度</span><br><span class="line"></span><br><span class="line">char ReceiveBuffer[RECVBUFF];   &#x2F;&#x2F;接收缓冲区</span><br><span class="line">char SendBuffer[SENDBUFF];    &#x2F;&#x2F;发送缓冲区</span><br><span class="line"></span><br><span class="line">int main(int argc,char** argv)&#123;</span><br><span class="line">    int client;   &#x2F;&#x2F;对端(客户端)套接字文件描述符</span><br><span class="line">    int sfd &#x3D; socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);  &#x2F;&#x2F;创建套接字  ipv4协议簇  字节流套接字  使用TCP协议   (若第三个参数置零，则默认TCP&#x2F;SCTP协议)</span><br><span class="line">    if (sfd &#x3D;&#x3D; -1)&#123;</span><br><span class="line">        perror(&quot;create socket failed.&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct sockaddr_in saddr;  &#x2F;&#x2F;服务器端套接字地址结构</span><br><span class="line">    struct sockaddr_in peer_saddr;  &#x2F;&#x2F; 对端(客户端)套接字地址结构</span><br><span class="line">    socklen_t peer_len &#x3D; sizeof(struct sockaddr);   &#x2F;&#x2F;由peer_saddr指定的套接字地址结构长度</span><br><span class="line">    memset(&amp;saddr,0,sizeof(saddr));  &#x2F;&#x2F;这里也可使用bzero()函数  </span><br><span class="line">    saddr.sin_family &#x3D; AF_INET;  &#x2F;&#x2F;指定ipv4协议簇</span><br><span class="line">    saddr.sin_port &#x3D; htons(PORT);  &#x2F;&#x2F;端口   由主机字节序转化为网络字节序</span><br><span class="line">    saddr.sin_addr.s_addr &#x3D; INADDR_ANY;  &#x2F;&#x2F;允许的ip地址 INADDR_ANY 即任意地址</span><br><span class="line">    if(bind(sfd,(struct sockaddr*)&amp;saddr,sizeof(struct sockaddr)) &#x3D;&#x3D; -1)&#123;   &#x2F;&#x2F;bind(). 绑定套接字 sfd 文件描述符 和 saddr 套接字地址结构</span><br><span class="line">        perror(&quot;bind socket error!&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(listen(sfd,BACKLOG) &#x3D;&#x3D; -1)&#123;  &#x2F;&#x2F;listen(). 启动监听  本步将sfd主动套接字转化为被动监听套接字</span><br><span class="line">        perror(&quot;listen error!&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(1)&#123;  &#x2F;&#x2F;无限循环接收客户端请求</span><br><span class="line">        client &#x3D; accept(sfd,(struct sockaddr*)&amp;peer_saddr,&amp;peer_len);   &#x2F;&#x2F;收到客户端请求，接受请求  否则本步阻塞监听</span><br><span class="line">        if (client &#x3D;&#x3D; -1)&#123;</span><br><span class="line">            perror(&quot;error in accept.&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;accept client:%s:%d\n&quot;,inet_ntoa(peer_saddr.sin_addr),peer_len);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(ReceiveBuffer,&#39;\0&#39;,sizeof(ReceiveBuffer));</span><br><span class="line">        memset(SendBuffer,&#39;\0&#39;,sizeof(SendBuffer));</span><br><span class="line">        </span><br><span class="line">        recv(client,ReceiveBuffer,RECVBUFF,0);  &#x2F;&#x2F;若客户端发送了数据，接收客户端发来的数据 否则本步阻塞接收数据</span><br><span class="line">        if((strcmp(ReceiveBuffer,&quot;&quot;)) &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;recv:%s\n&quot;,ReceiveBuffer);</span><br><span class="line"></span><br><span class="line">        strcpy(SendBuffer,Analysis(ReceiveBuffer));  &#x2F;&#x2F;分析数据</span><br><span class="line"></span><br><span class="line">        if (strcmp(SendBuffer,&quot;&quot;) !&#x3D; 0)&#123;</span><br><span class="line">            send(client,SendBuffer,SENDBUFF,0);  &#x2F;&#x2F;向客户端回返数据</span><br><span class="line">            printf(&quot;send:%s\n&quot;,SendBuffer);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    close(sfd);  &#x2F;&#x2F;关闭套接字</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中第23行完成创建套接字，33-35行完成套接字地址结构设定，36行完成套接字绑定，41行完成套接字监听，47行完成接收客户端请求，58行完成接收客户端请求内容，64行完成客户端请求处理，67行完成客户端请求响应，71行完成关闭套接字。  </p>
<h2 id="0x05-客户端程序"><a href="#0x05-客户端程序" class="headerlink" title="0x05 客户端程序"></a>0x05 客户端程序</h2><p>服务器端写好了，客户端怎么写呢？其实客户端比服务器端容易很多，设置完套接字后无需绑定和监听的过程，可以直接选择连接服务器端。<br>使用套接字完成客户端构建一共需要6步：创建套接字，设置套接字地址结构，连接服务器，发送请求，接收服务器端响应，关闭套接字。<br>这里只对第三步进行解释，其他的步骤与服务器端相似，不再赘述。  </p>
<h4 id="第三步-连接服务器"><a href="#第三步-连接服务器" class="headerlink" title="第三步 连接服务器"></a>第三步 连接服务器</h4><p>函数原型：<code>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code><br>sockfd: 客户端套接字描述符<br>addr: 服务器端套接字地址结构<br>addrlen: 套接字地址结构长度<br>这个函数用于客户端与服务器端建立连接，执行connect函数将激发TCP三次握手。按照TCP状态转换，connect()函数将会使当前套接字从CLOSED状态转移到SYN_SENT状态，若函数执行成功，则再转移到ESTABLISHED状态。  </p>
<h2 id="0x06-举一个客户端的例子"><a href="#0x06-举一个客户端的例子" class="headerlink" title="0x06 举一个客户端的例子"></a>0x06 举一个客户端的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet&#x2F;in.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;strings.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define PORT	 7546	&#x2F;&#x2F;连接端口</span><br><span class="line">#define BUFF     1048576</span><br><span class="line"></span><br><span class="line">char buf[BUFF];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int client_socket &#x3D; socket(AF_INET, SOCK_STREAM, 0);   &#x2F;&#x2F;创建和服务器连接套接字</span><br><span class="line">	if(client_socket &#x3D;&#x3D; -1)&#123;</span><br><span class="line">		perror(&quot;socket&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	struct sockaddr_in addr;</span><br><span class="line">	memset(&amp;addr, 0, sizeof(addr));</span><br><span class="line">	addr.sin_family &#x3D; AF_INET;  &#x2F;* Internet地址族 *&#x2F;</span><br><span class="line">    addr.sin_port &#x3D; htons(PORT);  &#x2F;* 端口号 *&#x2F;</span><br><span class="line">    addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);   &#x2F;* IP地址 *&#x2F;</span><br><span class="line">	inet_aton(&quot;127.0.0.1&quot;, &amp;(addr.sin_addr));</span><br><span class="line">	int addrlen &#x3D; sizeof(addr);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;连接服务器</span><br><span class="line">	int listen_socket &#x3D;  connect(client_socket,  (struct sockaddr *)&amp;addr, addrlen);</span><br><span class="line">	if(listen_socket &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;connect&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;成功连接到服务器\n&quot;);</span><br><span class="line"></span><br><span class="line">	char buf[SIZE] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	while(1)&#123;</span><br><span class="line">		printf(&quot;请输入：&quot;);</span><br><span class="line">		scanf(&quot;%s&quot;, buf);</span><br><span class="line">		send(client_socket, buf, strlen(buf),0);</span><br><span class="line">		</span><br><span class="line">		int ret &#x3D; recv(client_socket, buf, strlen(buf),0);</span><br><span class="line">		</span><br><span class="line">		printf(&quot;buf &#x3D; %s&quot;, buf);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		if(strncmp(buf, &quot;END&quot;, 3) &#x3D;&#x3D; 0)     &#x2F;&#x2F;当输入END时客户端退出</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listen_socket);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x07-总结一下"><a href="#0x07-总结一下" class="headerlink" title="0x07 总结一下"></a>0x07 总结一下</h2><p>我们成功地实现了使用C语言完成类似js的前后端交互。不过我们并没有使用http的应用层协议，而是仅仅发送数据，处理数据，接收数据。网络编程的内容多且非常复杂，文章写出来的仅仅是冰山一角。例如，我们现在写的服务器没有太多的错误处理，健壮性不足，不能满足高并发需求，等等。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://su29029.github.io/2020/08/28/%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9Fjs%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/" data-id="ckedou6gm0010yvtyh2w381sz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c%E8%AF%AD%E8%A8%80/" rel="tag">c语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习win32编程-1-创建窗口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/28/%E5%AD%A6%E4%B9%A0win32%E7%BC%96%E7%A8%8B-1-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/" class="article-date">
  <time datetime="2020-08-28T02:30:29.000Z" itemprop="datePublished">2020-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/windows%E7%BC%96%E7%A8%8B/">windows编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/28/%E5%AD%A6%E4%B9%A0win32%E7%BC%96%E7%A8%8B-1-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/">学习win32编程(1)--创建窗口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要学习win32编程"><a href="#为什么要学习win32编程" class="headerlink" title="为什么要学习win32编程"></a>为什么要学习win32编程</h2><p>期中考试结束了，又回想起了期中考试前花了八天时间搞出来的小脚本，决定完善一下，增加点稳定性。<br>脚本当时最大的问题就是浏览器最小化之后，视频的自动切换下一集的功能出现了故障，导致可能花了4，5集的时间结果只播放了一集。花了一天时间研究了一下chrome浏览器的工作原理，发现了setInterval函数的延迟不由JavaScript引擎完成而是由浏览器的一个定时器线程完成的，浏览器最小化之后那个线程停止运行导致setInterval函数延迟出错。具体的工作原理参见我的另一篇文章<a href="su29029.github.io/2019/11/15/%E6%B5%85%E6%9E%90chrome%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html">浅析chrome的工作原理</a>。</p>
<p>于是决定修复它。想了两种思路，第一种是借助Chrome的扩展程序，扩展程序可以获取活动选项卡，而且浏览器最小化后不会停止运行。但是还是没法保证setInterval函数在浏览器最小化之后仍然能够正常运行。第二种思路就是借助WebAssembly在js代码中嵌入底层c++代码，借助Windows的API来实现对浏览器相关线程的控制，这样就可以避免定时器线程暂停的问题。当然这个也是一个初步的思路，可行性只有在具体实践之后才能知道。(可能还需要借助扩展程序完成)</p>
<p>既然要在底层通过c++来操控浏览器，那win32编程是绕不过了。但也只是初步的把一些需要用到的知识学一下，顺便了解一下windows系统的运作原理等等。顺便把C语言也复习复习吧。ok，那就开始。</p>
<h2 id="最基本的操作–创建窗口"><a href="#最基本的操作–创建窗口" class="headerlink" title="最基本的操作–创建窗口"></a>最基本的操作–创建窗口</h2><h3 id="0x00-引入"><a href="#0x00-引入" class="headerlink" title="0x00 引入"></a>0x00 引入</h3><p>我们就先来一个最简单的windows应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	MessageBox(NULL,&quot;Hello Windows!&quot;,&quot;Hello Windows!&quot;,MB_OK);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码运行后会生成一个命令行界面和对话框，图标为Windows默认图标，标题为”Hello Windows!”，内容为”Hello Windows!”，再加上一个”确定”按钮。</p>
<p>恭喜我们成功生成了一个命令行外的东西–对话框！我们走出了摆脱命令行的巨大一步。</p>
<p>当然这个程序非常简单，而且说到底这个程序依然是属于c++程序，不能算是Windows程序，因为他的入口点函数依然是main函数，main函数是控制台应用程序的入口点。所以程序运行的时候依然会出现一个shell的界面。</p>
<p>那么我们如何不让他生成这个命令行呢，我们需要换一种思路了。</p>
<h3 id="0x01-创建入口点函数WinMain"><a href="#0x01-创建入口点函数WinMain" class="headerlink" title="0x01 创建入口点函数WinMain"></a>0x01 创建入口点函数WinMain</h3><p>Windows编程中，我们需要使用WinMain函数来创建程序入口点。于是我们把上述代码修改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int CALLBACK WinMain(</span><br><span class="line">    _In_  HINSTANCE hInstance,</span><br><span class="line">    _In_  HINSTANCE hPrevInstance,</span><br><span class="line">    _In_  LPSTR lpCmdLine,</span><br><span class="line">    _In_  int nCmdShow</span><br><span class="line">  )&#123;</span><br><span class="line">	MessageBox(NULL,&quot;Hello Windows!&quot;,&quot;Hello Windows!&quot;,MB_OK);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行，发现刚刚的命令行没有了，只剩下一个对话框了！！！</p>
<p>我们来解释一下这个函数吧。这个WinMain函数是Windows程序的应用程序入口点，程序将从WinMain处开始执行。有一点需要注意，c++中的main函数里面的参数是可以不写的，但这里不行。四个参数都要写。<br>WinMain函数前面带了一个CALLBACK，这个CALLBACK是什么意思呢，我们再IDE上按住CTRL键左键点击这个函数转到函数定义，发现CALLBACK是一个宏，原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CALLBACK   __stdcall</span><br></pre></td></tr></table></figure>
<p>这时我们发现这个CALLBACK其实就是__stdcall，那么__stdcall是什么？这个其实是跟C语言的__cdecl对应的，都是一种调用约定,这个可以不用具体深究它，可以将这个__stdcall理解为专门来调用Win API函数的就行了。<br>CALLBACK有什么特别功能吗？字面意思”callback”是回调的意思。我们的WinMain函数由操作系统调用，但WinMain函数具体做什么，操作系统就不管了，它有可能回头调用操作系统的一些API都是没有问题的。</p>
<p>下面我们来分析WinMain的这四个参数。我们经常会看到诸如HANDLE，HINSTANCE，HBRUSH，WPARAM。LPARAM，HICON，HWND等一大串数据类型，感觉好多好复杂啊……其实并不是，他们说到底还是C++的那几种基本数据类型，只是微软为了方便使用而重新定义了他们罢了。例如HINSTANCE类型，CTRL加鼠标左键转到定义，发现HINSTANCE也是一个宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void *HINSTANCE;</span><br></pre></td></tr></table></figure>
<p>第一个参数hInstance是当前应用程序的实例句柄，第二个参数hPrevInstance是前一个应用程序的实例句柄(如果你把这个应用程序开了两个的话)，比如我把a.exe运行了两个实例，进程列表中会有两个a.exe，这时候第一次运行的实例号假设为01，就传递第一个参数hInstance，第二次运行的假设实例号为02，就传给了hPrevInstance参数。<br>第三个参数lpCmdLine名字上就可以理解到是命令行参数，但是LPSTR是什么意思呢？它是一个字符串，char*类型(注意，Windows编程中，所有以lp开头的，均为指针类型，比如LPSTR可以理解为long point string)<br>第四个参数是nCmdShow，它指明了主窗口显示方式，它有以下几个值：  </p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>SW_HIDE  0</td>
<td>Hides the window and activates another window.</td>
</tr>
<tr>
<td>SW_MAXIMIZE  3</td>
<td>Maximizes the specified window.</td>
</tr>
<tr>
<td>SW_MINIMIZE  6</td>
<td>Minimizes the specified window and activates the next top-level window in the Z order.</td>
</tr>
<tr>
<td>SW_RESTORE  9</td>
<td>Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window.</td>
</tr>
<tr>
<td>SW_SHOW  5</td>
<td>Activates the window and displays it in its current size and position.</td>
</tr>
<tr>
<td>SW_SHOWMAXIMIZED  3</td>
<td>Activates the window and displays it as a maximized window.</td>
</tr>
<tr>
<td>SW_SHOWMINIMIZED  2</td>
<td>Activates the window and displays it as a minimized window.</td>
</tr>
<tr>
<td>SW_SHOWMINNOACTIVE  7</td>
<td>Displays the window as a minimized window. This value is similar to <strong>SW_SHOWMINIMIZED</strong>, except the window is not activated.</td>
</tr>
<tr>
<td>SW_SHOWNA  8</td>
<td>Displays the window in its current size and position. This value is similar to <strong>SW_SHOW</strong>, except the window is not activated.</td>
</tr>
<tr>
<td>SW_SHOWNOACTIVE  4</td>
<td>Displays a window in its most recent size and position. This value is similar to <strong>SW_SHOWNORMAL</strong>, except the window is not activated.</td>
</tr>
<tr>
<td>SW_SHOWNORMAL  1</td>
<td>Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time.</td>
</tr>
</tbody></table>
<p>完成了WinMain,我们还需要一个WindowProc函数，这个函数是用来处理传给我们应用程序的消息的(即消息处理函数)。该函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这个函数也可以不叫WindowProc，可以命名成任何你想要的名字，但是命名成WindowProc更利于理解，而且也符合一般的消息处理函数的命名法则。</span><br><span class="line">LRESULT CALLBACK WindowProc(</span><br><span class="line">	_In_  HWND hWnd,</span><br><span class="line">	_In_  UINT uMsg,</span><br><span class="line">	_In_  WPARAM wParam,</span><br><span class="line">	_In_  LPARAM lParam</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	return DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowProc用来处理源源不断从操作系统发送来的消息，当然如果我们对这些消息不感兴趣或者不想处理的话，就交给DefWindowProc函数来处理，这是Windows系统默认的消息处理函数。<br>其中：<br>hWnd是当前窗口的句柄。<br>uMsg是系统发过来的消息。<br>wParam是消息参数。<br>lParam是消息参数。<br>这个函数也带有CALLBACK，同理，这也是操作系统调用的函数。  </p>
<h3 id="0x02-设计和注册窗口类"><a href="#0x02-设计和注册窗口类" class="headerlink" title="0x02 设计和注册窗口类"></a>0x02 设计和注册窗口类</h3><p>设计窗口类，其实就是设计我们程序的主窗口，如有没有标题栏，背景什么颜色，有没有边框，可不可以调整大小等。要设计窗口类，我们用到一个结构————</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASS &#123;</span><br><span class="line">  UINT      style;</span><br><span class="line">  WNDPROC   lpfnWndProc;</span><br><span class="line">  int       cbClsExtra;</span><br><span class="line">  int       cbWndExtra;</span><br><span class="line">  HINSTANCE hInstance;</span><br><span class="line">  HICON     hIcon;</span><br><span class="line">  HCURSOR   hCursor;</span><br><span class="line">  HBRUSH    hbrBackground;</span><br><span class="line">  LPCTSTR   lpszMenuName;</span><br><span class="line">  LPCTSTR   lpszClassName;</span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br></pre></td></tr></table></figure>
<p>通常情况下，我们用tagWNDCLASS就可以了，当然还有一个tagWNDCLASSEX的扩展结构，在API里面，凡是看到EX结尾的都是扩展的意思，比如CreateWindowEx就是CreateWindow的扩展函数。</p>
<p>第一个成员是窗口的类样式，注意，不要和窗口样式（WS_xxxxx）混淆了，这里指的是这个窗口类的特征，不是窗口的外观特征，这两个style是不一样的。</p>
<p>它的值可以参考MSDN，通常我们只需要两个就可以了——CS_HREDRAW | CS_VREDRAW，从名字就看出来了，就是同时具备水平重画和垂直重画。因为当我们的窗口显示的时候，被其他窗口挡住后重新显示，或者大小调整后，窗口都要发生绘制，就像我们在纸上涂鸦一样，每次窗口的变化都会“粉刷”一遍，并发送WM_PAINT消息。</p>
<p>lpfnWndProc参数就是用来设置你用哪个WindowProc来处理消息，前面我说过，我们只要不更改回调函数的返回值和参数的类型和顺序，就可以随意设置函数的名字，那为什么系统可以找到我们用的回调函数呢，对的，就是通过lpfnWndProc传进去的，它是一个函数指针，也就是它里面保存的是我们定义的WindowProc的入口地址，使用很简单，我们只需要把函数的名字传给它就可以了。</p>
<p>cbClsExtra和cbWndExtra通常不需要，设为0就OK。hInstance是当前应用程序的实例句柄，从WinMain的hInstance参数中可以得到。hIcon和hCursor就不用我说了，看名字就知道了。</p>
<p>hbrBackground是窗口的背景色，你也可以不设置，但在处理WM_PAINT消息时必须绘制窗口背景。也可以直接用系统定义的颜色，MSDN为我们列出这些值，大家不用记，直接到MSDN拿来用就行了，这些都比较好理解，看名字就知道了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">COLOR_ACTIVEBORDER</span><br><span class="line">COLOR_ACTIVECAPTION</span><br><span class="line">COLOR_APPWORKSPACE</span><br><span class="line">COLOR_BACKGROUND</span><br><span class="line">COLOR_BTNFACE</span><br><span class="line">COLOR_BTNSHADOW</span><br><span class="line">COLOR_BTNTEXT</span><br><span class="line">COLOR_CAPTIONTEXT</span><br><span class="line">COLOR_GRAYTEXT</span><br><span class="line">COLOR_HIGHLIGHT</span><br><span class="line">COLOR_HIGHLIGHTTEXT</span><br><span class="line">COLOR_INACTIVEBORDER</span><br><span class="line">COLOR_INACTIVECAPTION</span><br><span class="line">COLOR_MENU</span><br><span class="line">COLOR_MENUTEXT</span><br><span class="line">COLOR_SCROLLBAR</span><br><span class="line">COLOR_WINDOW        &#x2F;*  这个就是窗口的默认背景色  *&#x2F;</span><br><span class="line">COLOR_WINDOWFRAME</span><br><span class="line">COLOR_WINDOWTEXT</span><br></pre></td></tr></table></figure>
<p>lpszMenuName指的是菜单的ID，没有菜单就NULL，lpszClassName就是我们要向系统注册的类名，字符，但不能与系统已存在的类名冲突。</p>
<p>随后，我们在WinMain中设计窗口类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;&#x2F; 类名</span><br><span class="line">WCHAR* cls_Name &#x3D; &quot;My Class&quot;;</span><br><span class="line">&#x2F;&#x2F; 设计窗口类</span><br><span class="line">WNDCLASS wc;</span><br><span class="line">wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">wc.lpfnWndProc &#x3D; WindowProc;</span><br><span class="line">wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">wc.hInstance &#x3D; hInstance;</span><br></pre></td></tr></table></figure>
<p>窗口类设计完成后，不要忘了向系统注册，这样系统才能知道有这个窗口类的存在。向操作系统注册窗口类，使用RegisterClass函数，它的参数是一个指向WNDCLASS结构体的指针，所以我们传递的时候，要加上&amp;符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册窗口类</span><br><span class="line">	RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure>


<h3 id="0x03-创建和显示窗口"><a href="#0x03-创建和显示窗口" class="headerlink" title="0x03 创建和显示窗口"></a>0x03 创建和显示窗口</h3><p>窗口类注册完成后，就应该创建窗口，然后显示窗口，调用CreateWindow创建窗口，如果成功，会返回一个窗口的句柄，我们对这个窗口的操作都要用到这个句柄。什么是句柄呢？其实它就是一串数字，只是一个标识而已，内存中会存在各种资源，如图标、文本等，为了可以有效标识这些资源，每一个资源都有其唯一的标识符，这样，通过查找标识符，就可以知道某个资源存在于内存中哪一块地址中。<br>创建窗口的函数CreateWindow返回一个HWND类型，它就是窗口类的句柄。函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HWND WINAPI CreateWindow(</span><br><span class="line"></span><br><span class="line">  _In_opt_  LPCTSTR lpClassName,      &#x2F;&#x2F; 窗口类名称</span><br><span class="line"></span><br><span class="line">  _In_opt_  LPCTSTR lpWindowName,  &#x2F;&#x2F; 窗口标题</span><br><span class="line"></span><br><span class="line">  _In_     DWORD dwStyle,                &#x2F;&#x2F; 窗口风格，或称窗口格式</span><br><span class="line"></span><br><span class="line">  _In_     int x,                                 &#x2F;&#x2F; 初始 x 坐标</span><br><span class="line"></span><br><span class="line">  _In_     int y,                                 &#x2F;&#x2F; 初始 y 坐标</span><br><span class="line"></span><br><span class="line">  _In_     int nWidth,                        &#x2F;&#x2F; 初始 x 方向尺寸</span><br><span class="line"></span><br><span class="line">  _In_     int nHeight,                       &#x2F;&#x2F; 初始 y 方向尺寸</span><br><span class="line"></span><br><span class="line">  _In_opt_  HWND hWndParent,        &#x2F;&#x2F; 父窗口句柄</span><br><span class="line"></span><br><span class="line">  _In_opt_  HMENU hMenu,               &#x2F;&#x2F; 窗口菜单句柄</span><br><span class="line"></span><br><span class="line">  _In_opt_  HINSTANCE hInstance,    &#x2F;&#x2F; 程序实例句柄</span><br><span class="line"></span><br><span class="line">  _In_opt_  LPVOID lpParam              &#x2F;&#x2F; 创建参数</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>(好复杂QAQ，嗯看着注释就能理解了。)<br>调用一下这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建窗口</span><br><span class="line">	HWND hWnd &#x3D; CreateWindow(</span><br><span class="line">		cls_Name,			&#x2F;&#x2F;类名，要和刚才注册的一致</span><br><span class="line">		&quot;应用程序&quot;,			&#x2F;&#x2F;窗口标题文字</span><br><span class="line">		WS_OVERLAPPEDWINDOW, 		&#x2F;&#x2F;窗口外观样式,这个具体的样式MSDN上搜吧，我这里就不罗列了</span><br><span class="line">		38,				&#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">		20,				&#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">		480,				&#x2F;&#x2F;窗口的宽度</span><br><span class="line">		250,				&#x2F;&#x2F;窗口的高度</span><br><span class="line">		NULL,				&#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">		NULL,				&#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">		hInstance,			&#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">		NULL);				&#x2F;&#x2F;没有附加数据，为NULL</span><br><span class="line">	if(hWnd &#x3D;&#x3D; NULL) 				&#x2F;&#x2F;检查窗口是否创建成功</span><br><span class="line">		return 0;</span><br></pre></td></tr></table></figure>
<p>窗口创建后，就要显示它，就像我们的产品做了，要向客户展示。显示窗口调用ShowWindow函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br></pre></td></tr></table></figure>
<p>既然要显示窗口了，那么ShowWindow的第一个参数就是刚才创建的窗口的句柄，第二个参数控制窗口如何显示，你可以从SW_XXXX中选一个，也可以用WinMain传进来的参数，还记得WinMain的最后一个参数吗？没错，就是它了。</p>
<h3 id="0x04-可选-更新窗口"><a href="#0x04-可选-更新窗口" class="headerlink" title="0x04 (可选)更新窗口"></a>0x04 (可选)更新窗口</h3><p>为什么更新窗口这一步可有可无呢？因为只要程序在运行着，只要不是最小化，只要窗口是可见的，那么，我们的应用程序会不断接收到WM_PAINT通知。(关于WM_PAINT后面再说)更新窗口调用的是UpdateWindow函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UpdateWindow(hWnd);</span><br></pre></td></tr></table></figure>

<h3 id="0x05-important-消息循环"><a href="#0x05-important-消息循环" class="headerlink" title="0x05 (important)消息循环"></a>0x05 (important)消息循环</h3><p>Windows操作系统是基于消息控制机制的，用户与系统之间的交互，程序与系统之间的交互，都是通过发送和接收消息来完成的。<br>我们知道，代码是不断往前执行的，像我们刚才写的WinMain函数一样，如果你现在运行程序，你会发现什么都没有，是不是程序不能运行呢，不是，其实程序是运行了，只是它马上结束了，只要程序执行跳出了WinMain的右大括号，程序就会结束了。那么，要如何让程序不结束了，可能大家注意到我们在C程序中可以用一个getchar()函数来等到用户输入，这样程序就人停在那里，直到用户输入内容。但我们的窗口应用不能这样做，因为用户有可能进行其他操作，如最小化窗口，移动窗口，改变窗口大小，或者点击窗口上的按钮等。因此，我们不能简地弄一个getchar在那里，这样就无法响应用户的其他操作了。<br>于是我们需要引入消息循环，只要有与用户交互，系统人不断地向应用程序发送消息通知，因为这些消息是不定时不断发送的，必须有一个绶冲区来存放，就好像你去银行办理手续要排队一样，我们从最前端取出一条一条消息处理，后面新发送的消息会一直在排队，直到把所有消息处理完，这就是消息队列。<br>要取出一条消息，调用GetMessage函数。函数会传入一个tagMSG结构体的指针，当收到消息，会填充tagMSG结构体中的成员变量，这样我们就知道我们的应用程序收到什么消息了，直到GetMessage函数取不到消息，条件不成立，循环跳出，这时应用程序就退出。<br>tagMSG结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagMSG &#123;</span><br><span class="line">    HWND   hWnd;</span><br><span class="line">    UINT   message;</span><br><span class="line">    WPARAM wParam;</span><br><span class="line">    LPARAM lParam;</span><br><span class="line">    DWORD  time;</span><br><span class="line">    POINT  pt;</span><br><span class="line">  &#125; MSG, *PMSG, *LPMSG;</span><br></pre></td></tr></table></figure>
<p>hWnd就不用说了，就是窗口句柄，哪个窗口的句柄？还记得WindowProc回调函数吗？你把这个函数交给了谁来处理，hWnd就是谁的句柄，比如我们上面的代码，我们是把WindowProc赋给了新注册的窗口类，并创建了主窗口，返回一个表示主窗口的句柄，所以，这里MSG中的hWnd指的就是我们的主窗口。<br>message就是我们接收到的消息，它是个无符号整数，所以我们操作的所有消息都是数字来的。wParam和lParam是消息的附加参数，也是数值来的。通常，lParam指示消息的处理结果，不同消息的结果（返回值）不同，具体参阅MSDN。</p>
<p>有了一个整数值来表示消息，我们为什么还需要附加参数呢？你不妨想一下，如果接收一条WM_LBUTTONDOWN消息，即鼠标左键按下时发送的通知消息，那么，我们不仅需要知道左键按下，我们更感兴趣的是，鼠标在屏幕上的哪个坐标处按下左键，按了几下，这时候，你只靠一条WM_LBUTTONDOWN是无法传递这么多消息的。可能我们需要把按下左键时的坐标放入wParam参数中；最典型的就是WM_COMMAND消息，因为只要你使用菜单，点击按钮都会发送这样一条消息，那么我怎么知道用户点了哪个按钮呢？如果窗口中只有一个按钮，那好办，但是，如果窗口上有10个按钮呢？而每一个按钮被单击都会发送WM_COMMAND消息，你能知道用户点击了哪个按钮吗？所以，我们要把用户点击了的那个按钮的句柄存到lParam参数中，这样一来，我们就可以判断出用户到底点击了哪个按钮了。</p>
<p>GetMessage函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI GetMessage(</span><br><span class="line">  _Out_     LPMSG lpMsg,</span><br><span class="line">  _In_opt_  HWND hWnd,</span><br><span class="line">  _In_      UINT wMsgFilterMin,</span><br><span class="line">  _In_      UINT wMsgFilterMax</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个函数在定义时带了一个WINAPI，应该猜到，它也是一个宏，而真实的值是__stdcall，前文中说过了。</p>
<p>第一个参数是以LP开头，还记得吗，我说过的，你应该想到它就是 MSG* ，一个指向MSG结构的指针。第二个参数是句柄，通常我们用NULL，因为我们会捕捉整个应用程序的消息。后面两个参数是用来过滤消息的，指定哪个范围内的消息接收，在此范围之外的消息拒收，如果不过滤就全设为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 消息循环</span><br><span class="line">	MSG msg;</span><br><span class="line">	while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>TranslateMessage是用于转换按键信息的，因为键盘按下和弹起会发送WM_KEYDOWN和WM_KEYUP消息，但如果我们只想知道用户输了哪些字符，这个函数可以把这些消息转换为WM_CHAR消息，它表示的就是键盘按下的那个键的字符，如“A”，这样我们处理起来就更方便了。</p>
<p>DispatchMessage函数是必须调用的，它的功能就相当于一根传送带，每收到一条消息，DispatchMessage函数负责把消息传到WindowProc让我们的代码来处理，如果不调用这个函数，我们定义的WindowProc就永远接收不到消息，此时应用程序无响应。(死机啦……)</p>
<h3 id="0x06-消息响应"><a href="#0x06-消息响应" class="headerlink" title="0x06 消息响应"></a>0x06 消息响应</h3><p>其实现在我们的应用程序是可以运行了，因为在WindowProc中我们调用了DefWindowProc，函数，消息我们不作任何处理，又把控制权路由回到操作系统来默认处理，所以，整个过程的消息循环是成立的，只不过我们做默认响应罢了。</p>
<h3 id="0x07-完整的创建窗口代码-不是Visual-Studio自动生成的"><a href="#0x07-完整的创建窗口代码-不是Visual-Studio自动生成的" class="headerlink" title="0x07 完整的创建窗口代码(不是Visual Studio自动生成的)"></a>0x07 完整的创建窗口代码(不是Visual Studio自动生成的)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">LRESULT CALLBACK WindowProc(</span><br><span class="line">	_In_  HWND hwnd,</span><br><span class="line">	_In_  UINT uMsg,</span><br><span class="line">	_In_  WPARAM wParam,</span><br><span class="line">	_In_  LPARAM lParam</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 程序入口点</span><br><span class="line">int CALLBACK WinMain(</span><br><span class="line">    _In_  HINSTANCE hInstance,</span><br><span class="line">    _In_  HINSTANCE hPrevInstance,</span><br><span class="line">    _In_  LPSTR lpCmdLine,</span><br><span class="line">    _In_  int nCmdShow</span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 类名</span><br><span class="line">	WCHAR* cls_Name &#x3D; L&quot;My Class&quot;;</span><br><span class="line">	&#x2F;&#x2F; 设计窗口类</span><br><span class="line">	WNDCLASS wc;</span><br><span class="line">	wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">	wc.lpfnWndProc &#x3D; WindowProc;</span><br><span class="line">	wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">	wc.hInstance &#x3D; hInstance;</span><br><span class="line">	&#x2F;&#x2F; 注册窗口类</span><br><span class="line">	RegisterClass(&amp;wc);</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 创建窗口</span><br><span class="line">	HWND hwnd &#x3D; CreateWindow(</span><br><span class="line">		cls_Name,			&#x2F;&#x2F;类名，要和注册的一致</span><br><span class="line">		L&quot;我的应用程序&quot;,	&#x2F;&#x2F;窗口标题文字</span><br><span class="line">		WS_OVERLAPPEDWINDOW, &#x2F;&#x2F;窗口外观样式</span><br><span class="line">		38,				&#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">		20,				&#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">		480,				&#x2F;&#x2F;窗口的宽度</span><br><span class="line">		250,				&#x2F;&#x2F;窗口的高度</span><br><span class="line">		NULL,				&#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">		NULL,				&#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">		hInstance,			&#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">		NULL);				&#x2F;&#x2F;没有附加数据，为NULL</span><br><span class="line">	if(hwnd &#x3D;&#x3D; NULL) &#x2F;&#x2F;检查窗口是否创建成功</span><br><span class="line">		return 0;</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 显示窗口</span><br><span class="line">	ShowWindow(hwnd, SW_SHOW);</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 更新窗口</span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 消息循环</span><br><span class="line">	MSG msg;</span><br><span class="line">	while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 消息处理函数</span><br><span class="line">LRESULT CALLBACK WindowProc(</span><br><span class="line">	_In_  HWND hwnd,</span><br><span class="line">	_In_  UINT uMsg,</span><br><span class="line">	_In_  WPARAM wParam,</span><br><span class="line">	_In_  LPARAM lParam</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0xFF-什么？你说窗口创建失败？"><a href="#0xFF-什么？你说窗口创建失败？" class="headerlink" title="0xFF 什么？你说窗口创建失败？"></a>0xFF 什么？你说窗口创建失败？</h3><p>是啊，你的代码为什么窗口一创建就退出了？仔细想想……初学C语言的时候，老师告诉我们(或者自学的时候书上有提到)定义一个变量如果不初始化就直接运算操作的话，会出现未知错误。现在回到我们的代码里。我们发现WNDCLASS结构体成员没有初始化，好了，发现问题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASS wc;</span><br><span class="line">	wc.cbClsExtra &#x3D; 0;</span><br><span class="line">	wc.cbWndExtra &#x3D; 0;</span><br><span class="line">	wc.hCursor &#x3D; LoadCursor(hInstance, IDC_ARROW);;</span><br><span class="line">	wc.hIcon &#x3D; LoadIcon(hInstance, IDI_APPLICATION);;</span><br><span class="line">	wc.lpszMenuName &#x3D; NULL;</span><br><span class="line">	wc.style &#x3D; CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">	wc.lpfnWndProc &#x3D; WindowProc;</span><br><span class="line">	wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">	wc.hInstance &#x3D; hInstance;</span><br></pre></td></tr></table></figure>
<p>但是这样初始化它未免太麻烦，不如我们换个方式吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASS wc &#x3D; &#123; &#125;;</span><br><span class="line">wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">wc.lpfnWndProc &#x3D; WindowProc;</span><br><span class="line">wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">wc.hInstance &#x3D; hInstance;</span><br></pre></td></tr></table></figure>
<p>至于为什么可以这样，复习一下C语言基础吧。我们换一个简单的例子来看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> typedef struct rectStruct</span><br><span class="line"> &#123;</span><br><span class="line">	 int x;</span><br><span class="line">	 int y;</span><br><span class="line">	 int width;</span><br><span class="line">	 int height;</span><br><span class="line"> &#125; RECT, *PRECT;</span><br><span class="line"> </span><br><span class="line"> void main()</span><br><span class="line"> &#123;</span><br><span class="line">	 RECT rect &#x3D; &#123; 0, 0, 20, 30 &#125;;</span><br><span class="line">	 printf(&quot;矩形的坐标是：%d, %d\n矩形的大小：%d , %d&quot;, rect.x, rect.y, rect.width, rect.height);</span><br><span class="line">	 getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个表示矩形的结构体 RECT ，它有四个成员，分别横坐标，纵坐标，宽度，高度，但是，我们在声明和赋值中，我们只用了一对大括号，把每个成员的值，按照定义的顺序依次写到大括号中，即{ 0, 0, 20, 30 }，x的值为0，y的值为0，width为20，height的值为30。</p>
<p>也就是说，我们可以通过这种方法向结构变量赋值。<br>再回到那句代码<code>WNDCLASS wc = &#123; &#125;;</code>上，是不是好理解一些了？我们通过这种巧妙的办法为结构体的所有变量赋了初值。  </p>
<h3 id="0xFFFF-什么？程序不能退出？你在逗我？"><a href="#0xFFFF-什么？程序不能退出？你在逗我？" class="headerlink" title="0xFFFF 什么？程序不能退出？你在逗我？"></a>0xFFFF 什么？程序不能退出？你在逗我？</h3><p>通常情况下，当我们的主窗口关闭后，应用程序应该退出（木马程序除外），但是，我们刚才运行后发现，为什么我的窗口关了，但程序不退出呢？我们知道，要退出程序，就要跳出消息循环，而与关闭哪个窗口是无关的。因此，我们要解决两个问题：<br>1.如果跳出消息循环；<br>2.什么时候退出程序。<br>其实两个问题可以合并到一起解决。<br>当窗口被关闭后，为窗口所分配的内存会被销毁，同时，我们会收到一条WM_DESTROY消息，因而，我们只要在收到这条消息时调用PostQuitMessage函数，这个函数提交一条WM_QUIT消息，而在消息循环中，WM_QUIT消息使GetMessage函数返回0，这样一来，GetMessage返回FALSE，就可以跳出消息循环了，这样应用程序就可以退出了。</p>
<p>所以，我们要做的就是捕捉WM_DESTROY消息，然后PostQuitMessage.<br>我们修改WindowProc函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LRESULT CALLBACK WindowProc(</span><br><span class="line">	_In_  HWND hwnd,</span><br><span class="line">	_In_  UINT uMsg,</span><br><span class="line">	_In_  WPARAM wParam,</span><br><span class="line">	_In_  LPARAM lParam</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	switch(uMsg)</span><br><span class="line">	&#123;</span><br><span class="line">	case WM_DESTROY:</span><br><span class="line">		&#123;</span><br><span class="line">			PostQuitMessage(0);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会收到很多消息，所以用switch判断一下是不是WM_DESTROY消息，如果是，退出应用程序。</p>
<p>好了，这样，我们一个完整的Windows应用程序就做好了。</p>
<p>下面是完整的代码(这回没问题了)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">LRESULT CALLBACK WindowProc(</span><br><span class="line">	_In_  HWND hwnd,</span><br><span class="line">	_In_  UINT uMsg,</span><br><span class="line">	_In_  WPARAM wParam,</span><br><span class="line">	_In_  LPARAM lParam</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 程序入口点</span><br><span class="line">int CALLBACK WinMain(</span><br><span class="line">    _In_  HINSTANCE hInstance,</span><br><span class="line">    _In_  HINSTANCE hPrevInstance,</span><br><span class="line">    _In_  LPSTR lpCmdLine,</span><br><span class="line">    _In_  int nCmdShow</span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 类名</span><br><span class="line">	WCHAR* cls_Name &#x3D; L&quot;My Class&quot;;</span><br><span class="line">	&#x2F;&#x2F; 设计窗口类</span><br><span class="line">	WNDCLASS wc &#x3D; &#123; &#125;;</span><br><span class="line">	wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">	wc.lpfnWndProc &#x3D; WindowProc;</span><br><span class="line">	wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">	wc.hInstance &#x3D; hInstance;</span><br><span class="line">	&#x2F;&#x2F; 注册窗口类</span><br><span class="line">	RegisterClass(&amp;wc);</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 创建窗口</span><br><span class="line">	HWND hwnd &#x3D; CreateWindow(</span><br><span class="line">		cls_Name,			&#x2F;&#x2F;类名，和刚才注册的一致</span><br><span class="line">		L&quot;我的应用程序&quot;,	&#x2F;&#x2F;窗口标题文字</span><br><span class="line">		WS_OVERLAPPEDWINDOW, &#x2F;&#x2F;窗口外观样式</span><br><span class="line">		38,					&#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">		20,					&#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">		480,				&#x2F;&#x2F;窗口的宽度</span><br><span class="line">		250,				&#x2F;&#x2F;窗口的高度</span><br><span class="line">		NULL,				&#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">		NULL,				&#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">		hInstance,			&#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">		NULL);				&#x2F;&#x2F;没有附加数据，为NULL</span><br><span class="line">	if(hwnd &#x3D;&#x3D; NULL) &#x2F;&#x2F;检查窗口是否创建成功</span><br><span class="line">		return 0;</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 显示窗口</span><br><span class="line">	ShowWindow(hwnd, SW_SHOW);</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 更新窗口</span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F; 消息循环</span><br><span class="line">	MSG msg;</span><br><span class="line">	while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK WindowProc(</span><br><span class="line">	_In_  HWND hwnd,</span><br><span class="line">	_In_  UINT uMsg,</span><br><span class="line">	_In_  WPARAM wParam,</span><br><span class="line">	_In_  LPARAM lParam</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	switch(uMsg)</span><br><span class="line">	&#123;</span><br><span class="line">	case WM_DESTROY:</span><br><span class="line">		&#123;</span><br><span class="line">			PostQuitMessage(0);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://su29029.github.io/2020/08/28/%E5%AD%A6%E4%B9%A0win32%E7%BC%96%E7%A8%8B-1-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/" data-id="ckedou6he0037yvty5g7n0cgd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows%E7%BC%96%E7%A8%8B/" rel="tag">windows编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-谈谈对MVC，MVP，MVVM设计模式的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/28/%E8%B0%88%E8%B0%88%E5%AF%B9MVC%EF%BC%8CMVP%EF%BC%8CMVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time datetime="2020-08-28T02:27:43.000Z" itemprop="datePublished">2020-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web/">web</a>►<a class="article-category-link" href="/categories/web/web%E5%BC%80%E5%8F%91/">web开发</a>►<a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/28/%E8%B0%88%E8%B0%88%E5%AF%B9MVC%EF%BC%8CMVP%EF%BC%8CMVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/">谈谈对MVC，MVP，MVVM设计模式的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>设计模式，emmmm，感觉很高深的样子，虽然感觉离我这个菜鸡还很遥远，不过了解一下还是没坏处。</p>
<h2 id="0x01-关于MVC设计模式"><a href="#0x01-关于MVC设计模式" class="headerlink" title="0x01 关于MVC设计模式"></a>0x01 关于MVC设计模式</h2><p>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<img src='../assets/img/MVC,MVP,MVVM设计模式/MVC设计模式.jpg'>

<p>MVC模式最早由Trygve Reenskaug在1978年提出，是施乐帕罗奥多研究中心在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式透过对复杂度的简化，使程序结构更加直观。软件系统透过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。</p>
<p>MVC模式在概念上强调 Model, View, Controller 的分离，各个模块也遵循着由 Controller 来处理消息，Model 掌管数据源，View 负责数据显示的职责分离原则，因此在实现上，MVC 模式的 Framework 通常会将 MVC 三个部分分离实现：  </p>
<p>Model 负责数据访问，较现代的 Framework 都会建议使用独立的数据对象 (DTO, POCO, POJO 等) 来替代弱类型的集合对象。数据访问的代码会使用 Data Access 的代码或是 ORM-based Framework，也可以进一步使用 Repository Pattern 与 Unit of Works Pattern 来切割数据源的相依性。</p>
<p>Controller负责处理消息，较高端的 Framework 会有一个默认的实现来作为 Controller 的基础，例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等，在职责分离原则的基础上，每个 Controller 负责的部分不同，因此会将各个 Controller 切割成不同的文件以利维护。</p>
<p>View负责显示数据，这个部分多为前端应用，而 Controller 会有一个机制将处理的结果 (可能是 Model, 集合或是状态等) 交给 View，然后由 View 来决定怎么显示。例如 Spring Framework 使用 JSP 或相应技术，ASP.NET MVC 则使用 Razor 处理数据的显示。</p>
<p>总的来讲，MVC是比较直观的架构模式，用户进行操作，View接收用户的输入操作，传递给Controller进行业务逻辑处理，Model实现数据持久化，并将结果反馈给View，完成一次MVC模式。</p>
<h2 id="0x02-关于MVP设计模式"><a href="#0x02-关于MVP设计模式" class="headerlink" title="0x02 关于MVP设计模式"></a>0x02 关于MVP设计模式</h2><p>Model-View-Presenter (MVP) 是用户界面设计模式的一种，被广泛用于便捷自动化单元测试和在呈现逻辑中改良分离关注点。</p>
<p>Model 定义用户界面所需要被显示的数据模型，一个模型包含着相关的业务逻辑。</p>
<p>View 视图为呈现用户界面的终端，用以表现来自 Model 的数据，和用户命令路由再经过 Presenter 对事件处理后的数据。</p>
<p>Presenter 包含着组件的事件处理，负责检索 Model 获取数据，和将获取的数据经过格式转换与 View 进行沟通。</p>
<p>MVP 设计模式通常会再加上 Controller 做为整体应用程序的后端程序工作。</p>
<img src='../assets/img/MVC,MVP,MVVM设计模式/MVP设计模式.jpg'>

<p>MVP是把MVC中的Controller换成了Presenter（呈现），目的是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。</p>
<h2 id="0x03-关于MVVM设计模式"><a href="#0x03-关于MVVM设计模式" class="headerlink" title="0x03 关于MVVM设计模式"></a>0x03 关于MVVM设计模式</h2><p>MVVM（Model–view–viewmodel）是一种软件架构模式。</p>
<p>MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。<br><img src='../assets/img/MVC,MVP,MVVM设计模式/MVVM设计模式1.jpg'></p>
<p>MVVM将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。即，ViewModel 是一个 View 信息的存储结构，ViewModel 和 View 上的信息是一一映射关系。</p>
<h4 id="使用MVVM模式的好处"><a href="#使用MVVM模式的好处" class="headerlink" title="使用MVVM模式的好处"></a>使用MVVM模式的好处</h4><p>低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。<br>可重用性。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。<br>独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。<br>可测试性。可以针对ViewModel来对界面(View)进行测试<br>使用 MVVM 模式，程序的 UI 和其背后的展现与业务逻辑将被分离至三个类中：<br>1-视图，封装 UI 与 UI 逻辑<br>2-模型视图，封装展示逻辑与状态<br>3-模型，封装程序的业务逻辑以及数据<br>在 MVVM 模式中，视图通过数据绑定以及命令行与视图模型交互，并改变事件通知。视图模型查询观察并协调模型更新，转换，校验以及聚合数据，从而在视图显示。<br>下图展示了 MVVM 类以及它们之间的交互：<br><img src='../assets/img/MVC,MVP,MVVM设计模式/MVVM设计模式2.jpg'></p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>总的来讲，MVC，MVP，MVVM是历史不断进步发展的产物，随着业务需求的扩大，软件规模的提升，用户需求的提高，催生出了软件工程，催生出了这些设计模式。对每种设计模式，我们既应当看到它们的最大优点，也不能忽视它们存在的问题。例如，MVVM模式的数据双向绑定存在着Bug调试困难，大项目占用内存多等问题。对于设计模式，在不同的场合，应当具体问题具体分析，使用最适合项目开发的设计模式，而不能一味追求新技术或是守旧，我们需要保持的是一个拥抱变化的心，以及理性分析的态度。在新技术的面前，不盲从，不守旧，一切的决策都应该建立在认真分析的基础上，这样才能应对技术的变化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://su29029.github.io/2020/08/28/%E8%B0%88%E8%B0%88%E5%AF%B9MVC%EF%BC%8CMVP%EF%BC%8CMVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="ckedou6gu001kyvty3yduet1o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-究竟怎么理解restful设计风格？我喜欢这个比喻" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/28/%E7%A9%B6%E7%AB%9F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3restful%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%EF%BC%9F%E6%88%91%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%AF%94%E5%96%BB/" class="article-date">
  <time datetime="2020-08-28T02:24:43.000Z" itemprop="datePublished">2020-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web/">web</a>►<a class="article-category-link" href="/categories/web/web%E5%BC%80%E5%8F%91/">web开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/28/%E7%A9%B6%E7%AB%9F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3restful%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%EF%BC%9F%E6%88%91%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%AF%94%E5%96%BB/">究竟怎么理解restful设计风格？我喜欢这个比喻</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>REST – REpresentational State Transfer 直译：表现层状态转移。这是什么鬼？？？</p>
</blockquote>
<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>举个例子，现在很多应用里面都支持有分享到微信，分享到QQ，分享到知乎这样的分享功能，这个功能的实现其实就是一种API，相当于腾讯，知乎已经将这个API封装好了，其他应用如果想要调用，直接调用即可。而restful就是这种API的设计模式。</p>
<blockquote>
<p>REST – REpresentational State Transfer<br>首先，之所以晦涩是因为前面主语被去掉了，全称是 Resource Representational State Transfer：通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：<br>Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；<br>Representational：某种表现形式，比如用JSON，XML，JPEG等；<br>State Transfer：状态变化。通过HTTP动词实现。</p>
</blockquote>
<h5 id="简单来讲，我们可以这么理解restful"><a href="#简单来讲，我们可以这么理解restful" class="headerlink" title="简单来讲，我们可以这么理解restful"></a>简单来讲，我们可以这么理解restful</h5><p>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC等）描述操作。<br>1、看url就知道要什么<br>2、看http method就知道干什么<br>3、看http status code就知道结果如何</p>
<p>其实开始了解restful的时候我是一脸懵逼的，不过现在稍微理解了，举个生动一点的例子吧</p>
<h3 id="Level-0-面向前台"><a href="#Level-0-面向前台" class="headerlink" title="Level 0 - 面向前台"></a>Level 0 - 面向前台</h3><hr>
<p>我们在咖啡店向前台点了一杯拿铁，这个过程可以用这段文字来描述：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>: <span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡，接着，前台给我们返回这么一串回复：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询卡号为447031335的卡的余额，查询的结果返回来了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;balance&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没钱……<br>哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Level-1-面向资源"><a href="#Level-1-面向资源" class="headerlink" title="Level 1 - 面向资源"></a>Level 1 - 面向资源</h3><hr>
<p>现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个资源都有专人负责，我们可以直接面向资源操作。<br>比如还是下单，请求的内容不变，但是我们多了一条消息:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//orders</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>: <span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多了一个斜杠和orders，这是什么意思？<br>这个表示我们这个请求是发给哪个资源的，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作。<br>接着还是会返回订单的编号给我们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们还是要查询会员卡余额，这次请求的资源变成了cards：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cards</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是取消订单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//orders</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Level2-打上标签"><a href="#Level2-打上标签" class="headerlink" title="Level2 - 打上标签"></a>Level2 - 打上标签</h3><hr>
<p>接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的‘POST’，表示这是一笔新增资源的请求。<br>其他种类的请求，比如查询类的，用‘GET’表示，删除类的，用‘DELETE’表示，修改用PATCH表示。<br>来，我们再来重复上面那个过程，来一杯拿铁：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>: <span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增，返回的内容还是一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是查询会员卡余额，这次也简化了很多：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /cards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;cardId&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个请求我们还可以进一步优化为这样：<br><code>GET /cards/123456</code><br>直接把要查询的卡号写在后面了。<br>没错，接着，取消订单：<br><code>DELETE /orders/1</code></p>
<h3 id="Level-3-完美服务"><a href="#Level-3-完美服务" class="headerlink" title="Level 3 - 完美服务"></a>Level 3 - 完美服务</h3><hr>
<p>忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着：<br><code>DELETE /orders/&#123;orderId&#125;</code><br>顾客反问道，谁会去看那个啊，店员不服，又说到，你瞎了啊你……后面两人吵着吵着还打了起来… <br>噗，真是悲剧…<br>有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。现在，我们还是发出请求，请求内容和上一次一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>: <span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这次返回时多了些内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;link&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;rel&quot;</span>: <span class="string">&quot;cancel&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/order/1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，接着你就可以这样子来取消订单啦：<br><code>DELETE /orders/1</code><br>哈哈，这服务真是贴心，以后再也不用担心店员和顾客打起来了。<br>Level3的Restful API，给使用者带来了很大的遍历，使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求。<br>现在绝大多数的RESTful接口都做到了Level2的层次，做到Level3的比较少。当然，这个模型并不是一种规范，只是用来理解Restful的工具。所以，做到了Level2，也就是面向资源和使用Http动词，就已经很Restful了。</p>
<blockquote>
<h5 id="Levels的意义"><a href="#Levels的意义" class="headerlink" title="Levels的意义"></a>Levels的意义</h5><p>Level 1 解释了如何通过分治法(Divide and Conquer)来处理复杂问题，将一个大型的服务端点(Service Endpoint)分解成多个资源。<br>Level 2 引入了一套标准的动词，用来以相同的方式应对类似的场景，移除不要的变化。<br>Level 3 引入了可发现性(Discoverability)，它可以使协议拥有自我描述(Self-documenting)的能力。<br>这一模型帮助我们思考我们想要提供的HTTP服务是何种类型的，同时也勾勒出人们和它进行交互时的期望。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://su29029.github.io/2020/08/28/%E7%A9%B6%E7%AB%9F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3restful%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%EF%BC%9F%E6%88%91%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%AF%94%E5%96%BB/" data-id="ckedou6gp0018yvty7rnoath5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-当在浏览器中输入www-baidu-com并按下回车后，都发生了什么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/28/%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5www-baidu-com%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%EF%BC%8C%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2020-08-28T01:42:52.000Z" itemprop="datePublished">2020-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web/">web</a>►<a class="article-category-link" href="/categories/web/web%E5%BC%80%E5%8F%91/">web开发</a>►<a class="article-category-link" href="/categories/web/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/28/%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5www-baidu-com%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%EF%BC%8C%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">当在浏览器中输入www.baidu.com并按下回车后，都发生了什么</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>让我们从零开始，从回车键按下到页面渲染完毕，从计算机和计算机网络角度(数据通信部分就不分析了，越弄越复杂)详细分析这个看似简单实则极度复杂的过程，争取考虑到每一个细节。欢迎补充。</p>
</blockquote>
<h2 id="0x01-回车键按下（物理级-硬件级）"><a href="#0x01-回车键按下（物理级-硬件级）" class="headerlink" title="0x01 回车键按下（物理级/硬件级）"></a>0x01 回车键按下（物理级/硬件级）</h2><hr>
<p>一个专用于回车键的电流回路被直接或者通过电容器闭合了，使得少量的电流进入了键盘的<strong>逻辑电路系统</strong>。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除，并将按键开关的电位弹跳变化转化为键盘码值。回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。（现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。）</p>
<blockquote>
<p>USB键盘<br>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压<br>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内<br>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据<br>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包<br>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机<br>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释,之后按键的码值被传输到操作系统的<strong>硬件抽象层</strong></p>
</blockquote>
<blockquote>
<p>虚拟键盘（触屏设备)<br>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标<br>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮<br>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息<br>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件  </p>
</blockquote>
<blockquote>
<p>非USB键盘：产生中断信号<br>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后<strong>操作系统内核</strong>出场了。<br>(当中断发生时，CPU 会停下当前运行的程序，保存当前执行状态（如 PC 值（ PC是一个16位的计数器。用于存放和指示下一条要执行的指令的地址）），进入 IRQ 状态（中断处理线状态），然后跳转到对应的中断处理程序执行)</p>
</blockquote>
<h2 id="0x02-操作系统级响应"><a href="#0x02-操作系统级响应" class="headerlink" title="0x02 操作系统级响应"></a>0x02 操作系统级响应</h2><hr>
<h4 id="Windows系统-一个WM-KEYDOWN消息被发往应用程序"><a href="#Windows系统-一个WM-KEYDOWN消息被发往应用程序" class="headerlink" title="[Windows系统]一个WM_KEYDOWN消息被发往应用程序"></a>[Windows系统]一个WM_KEYDOWN消息被发往应用程序</h4><p>人体学接口设备(HID)把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动)进行交互，之后它又去调用 Win32K.sys 。这些都是发生在内核模式（对比操作系统的用户模式）。</p>
<p>Win32K.sys 通过 GetForegroundWindow() API函数（该函数获取用户当前工作窗口的句柄）找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制(该机制在Window的主线程上做一个死循环，不断地去消息泵里去检查是否有消息到达，如果有消息抵达该窗口对象，则取出该消息，交付窗口过程去做处理。)调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>
<p>Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。</p>
<p>当前活跃的句柄hWnd是一个edit control控件，这种情况下，WindowProc有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。</p>
<h4 id="Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序"><a href="#Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序" class="headerlink" title="(Mac OS X)一个 KeyDown NSEvent被发往应用程序"></a>(Mac OS X)一个 KeyDown NSEvent被发往应用程序</h4><p>　　中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。</p>
<h4 id="GNU-Linux-Xorg-服务器监听键码值"><a href="#GNU-Linux-Xorg-服务器监听键码值" class="headerlink" title="(GNU/Linux)Xorg 服务器监听键码值"></a>(GNU/Linux)Xorg 服务器监听键码值</h4><p>　　当使用图形化的 X Server 时，X Server会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。</p>
<h2 id="0x03-解析URL"><a href="#0x03-解析URL" class="headerlink" title="0x03 解析URL"></a>0x03 解析URL</h2><hr>
<p>浏览器通过URL能够知道下面的信息：<br>Protocol “http”:使用HTTP协议<br>Resource “/“:请求的资源是主页(index)  </p>
<h4 id="输入的是URL还是搜索的关键字？"><a href="#输入的是URL还是搜索的关键字？" class="headerlink" title="输入的是URL还是搜索的关键字？"></a>输入的是URL还是搜索的关键字？</h4><p>　　当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>
<h3 id="检查HSTS列表"><a href="#检查HSTS列表" class="headerlink" title="检查HSTS列表"></a>检查HSTS列表</h3><p>浏览器检查自带的“预加载HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站。<br>如果网站在这个列表里，浏览器会使用HTTPS而不是HTTP协议，否则，最初的请求会使用HTTP协议发送<br>注意，一个网站哪怕不在HSTS列表里，也可以要求浏览器对自己使用HSTS政策进行访问。浏览器向网站发出第一个HTTP请求之后，网站会返回浏览器一个响应，请求浏览器只使用HTTPS发送请求。然而，就是这第一个HTTP请求，却可能会使用户收到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了HSTS列表。</p>
<h3 id="转换非ASCII的Unicode字符"><a href="#转换非ASCII的Unicode字符" class="headerlink" title="转换非ASCII的Unicode字符"></a>转换非ASCII的Unicode字符</h3><p>浏览器检查输入是否含有不是 a-z,A-Z,0-9,-或者.的字符<br>这里主机名是 google.com ，所以没有非ASCII的字符，如果有的话，浏览器会对主机名部分使用 Punycode 编码</p>
<blockquote>
<h4 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h4></blockquote>
<blockquote>
<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：<strong>安全套接字层超文本传输协议HTTPS</strong>，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<h5 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a>HTTP和HTTPS的基本概念</h5><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。  </p>
<h5 id="HTTP与HTTPS有什么区别？"><a href="#HTTP与HTTPS有什么区别？" class="headerlink" title="HTTP与HTTPS有什么区别？"></a>HTTP与HTTPS有什么区别？</h5><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br>HTTPS和HTTP的区别主要如下：<br>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  </p>
<h5 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h5><p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。<br>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤:<br>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。<br>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。<br>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>（5）Web服务器利用自己的私钥解密出会话密钥。<br>（6）Web服务器利用会话密钥加密与客户端之间的通信。  </p>
</blockquote>
<h2 id="0x04-DNS查询"><a href="#0x04-DNS查询" class="headerlink" title="0x04 DNS查询"></a>0x04 DNS查询</h2><hr>
<h5 id="浏览器检查域名是否在缓存当中"><a href="#浏览器检查域名是否在缓存当中" class="headerlink" title="浏览器检查域名是否在缓存当中"></a>浏览器检查域名是否在缓存当中</h5><p>如果缓存中没有，就去调用 gethostbyname 库函数（该函数返回一个指针，该指针对应于给定主机名，并包含主机名字和地址信息等主机信息）（操作系统不同 函数也不同）进行查询<br>gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地Hosts里，对于Hosts的位置，不同的操作系统有所不同<br>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向DNS 服务器发送一条DNS查询请求。DNS服务器是由网络通信栈提供的，通常是本地路由器或者ISP的缓存DNS服务器。  </p>
<h5 id="查询本地-DNS-服务器"><a href="#查询本地-DNS-服务器" class="headerlink" title="查询本地 DNS 服务器"></a>查询本地 DNS 服务器</h5><p>如果DNS服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询<br>如果DNS服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询  </p>
<h3 id="ARP（根据IP地址获取物理地址，TCP-IP协议簇）"><a href="#ARP（根据IP地址获取物理地址，TCP-IP协议簇）" class="headerlink" title="ARP（根据IP地址获取物理地址，TCP/IP协议簇）"></a>ARP（根据IP地址获取物理地址，TCP/IP协议簇）</h3><p>要想发送ARP广播，我们需要有一个目标IP地址，同时还需要知道用于发送ARP广播的接口的Mac地址。<br>首先查询ARP缓存（IP-MAC对照表的临时条目即ARP缓存）   </p>
<h4 id="如果缓存命中"><a href="#如果缓存命中" class="headerlink" title="如果缓存命中"></a>如果缓存命中</h4><p>返回结果：目标IP = MAC</p>
<h4 id="如果缓存没有命中"><a href="#如果缓存没有命中" class="headerlink" title="如果缓存没有命中"></a>如果缓存没有命中</h4><p>1查看路由表（路由选择），看看目标IP地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。<br>2查询选择的网络接口的MAC地址<br>3我们发送一个二层ARP请求：<br>ARP Request:<br>Sender MAC: interface：mac：address：here<br>Sender IP: interface.ip.goes.here<br>Target MAC: FF：FF：FF：FF：FF：FF (Broadcast)<br>Target IP: target.ip.goes.here<br>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>
<h5 id="1直连："><a href="#1直连：" class="headerlink" title="1直连："></a>1直连：</h5><p>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。</p>
<h5 id="2集线器："><a href="#2集线器：" class="headerlink" title="2集线器："></a>2集线器：</h5><p>如果我们连接到一个集线器，集线器会把ARP请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。</p>
<h5 id="3交换机："><a href="#3交换机：" class="headerlink" title="3交换机："></a>3交换机：</h5><p>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个MAC地址，如果没有找到，交换机会向所有其它端口广播这个ARP请求。<br>如果交换机的MAC/CAM表中有对应的条目，交换机会向有我们想要查询的MAC地址的那个端口发送ARP请求<br>ARP Reply:<br>Sender MAC: target：mac：address：here<br>Sender IP: target.ip.goes.here<br>Target MAC: interface：mac：address：here<br>Target IP: interface.ip.goes.here<br>如果路由器也“连接”在其中，它会返回一个 ARP Reply<br>现在我们有了DNS服务器或者默认网关的IP地址，我们可以继续DNS请求了：<br>使用53端口向DNS服务器发送UDP请求包，如果响应包太大，会使用TCP<br>如果本地/ISP DNS服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层DNS服务器做查询，直到查询到起始授权机构，如果找到会把结果返回  </p>
<h2 id="0x05-使用套接字（传输层）"><a href="#0x05-使用套接字（传输层）" class="headerlink" title="0x05 使用套接字（传输层）"></a>0x05 使用套接字（传输层）</h2><hr>
<p>当浏览器得到了目标服务器的IP地址，以及URL中给出来端口号（http协议默认端口号80，https默认端口号443），它会调用系统库函数 socket ，请求一个TCP流套接字（传输层实现端到端的通信，通信节点叫做套接字，表示方法，IP：端口号），对应参数是AF_INET（PF_INET也可以，ipv4用这个）  和 SOCK_STREAM（提供面向连接的稳定数据传输，即TCP）（这两个参数均应用在C语言socket编程中，函数原型：int socket(int domain,int type,int protocol);其中domain指定何种地址类型，如AF_INET，type设置通信协议类型，如SOCK_STREAM。）<br>这个请求首先被交给传输层，在传输层请求被封装成TCP segment（TCP包）。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取。<br>TCP segment被送往网络层，网络层会在其中再加入一个IP头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。<br>这个TCP packet接下来会进入链路层，链路层会在封包中加入frame头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的MAC地址。像前面说的一样，如果内核不知道网关的MAC地址，它必须进行ARP广播来查询其地址。<br>到了现在，TCP封包已经准备好了，可是使用下面的方式进行传输：<br>1以太网<br>2WiFi<br>3蜂窝数据网络  </p>
<blockquote>
<p>于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。<br>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。<br>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域（BGP协议），最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。  </p>
</blockquote>
<p><strong>上面的发送和接受过程在TCP连接期间会发生很多次</strong></p>
<h2 id="0x06-TCP连接的建立（三次握手）"><a href="#0x06-TCP连接的建立（三次握手）" class="headerlink" title="0x06 TCP连接的建立（三次握手）"></a>0x06 TCP连接的建立（三次握手）</h2><hr>
<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>请求端(客户端)会向服务端(被请求端)发送一个tcp报文，申请打开某一个端口。因为没有数据，所以这个报文仅包含一个tcp头。<br>其中：<br>SYN=1；当建立一个新的连接时， SYN标志变1。<br>序号；序号用来标识从客户端向服务端发送的数据字节流。<br>此时客户端进入SYN_SENT状态。  </p>
<h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端收到客户端的SYN包，也会发一个只包含tcp头的报文给客户端。<br>ACK=1；服务端确认收到信息<br>确认序号；客户端序号+1，作为应答<br>SYN=1；因为tcp的连接是双向的，服务端作为应答的同时请求建立连接。<br>此时服务端进入SYN_RECV状态  </p>
<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>ACK=1；客户端确认收到信息<br>确认序号；服务端序号+1，作为应答<br>此时客户端进入ESTABLISHED状态，服务端收到ACK后也会进入此状态  </p>
<p>可见，客户端和服务端都保留了对方的序号，这三次握手缺少任何一步都无法实现这一目标。在三次握手过程中，出现了一些中间状态。</p>
<p>这个问题的本质是, 信道不可靠, 但是通信双方需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.</p>
<h2 id="0x07-TLS-握手"><a href="#0x07-TLS-握手" class="headerlink" title="0x07 TLS 握手"></a>0x07 TLS 握手</h2><hr>
<p>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</p>
<p>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。</br><br>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥。<br>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥。<br>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值。<br>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个Finished 消息，也使用协商好的对称密钥加密。<br>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容。  </p>
<h2 id="0x08-HTTP服务器请求处理"><a href="#0x08-HTTP服务器请求处理" class="headerlink" title="0x08 HTTP服务器请求处理"></a>0x08 HTTP服务器请求处理</h2><hr>
<p>HTTPD(HTTP Daemon)在服务器端处理请求/相应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，与 Windows 上的 IIS。  </p>
<h4 id="HTTPD接收请求"><a href="#HTTPD接收请求" class="headerlink" title="HTTPD接收请求"></a>HTTPD接收请求</h4><p>服务器把请求拆分为以下几个参数：<br>HTTP请求方法(GET, POST, HEAD, PUT 和 DELETE )。在访问baidu这种情况下，使用的是GET方法<br>域名：baidu.com<br>请求路径/页面：/ (我们没有请求baidu.com下的指定的页面，因此 / 是默认的路径)<br>服务器验证其上已经配置了baidu.com的虚拟主机<br>服务器验证baidu.com接受GET方法<br>服务器验证该用户可以使用GET方法(根据IP地址，身份信息等)<br>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求<br>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件。(你可以重写这个规则，但是这个是最常用的)<br>服务器会使用指定的处理程序分析处理这个文件，比如假设baidu使用PHP，服务器会使用PHP解析index文件，并捕获输出，把PHP的输出结果给请求者  </p>
<h2 id="0x09-浏览器"><a href="#0x09-浏览器" class="headerlink" title="0x09 浏览器"></a>0x09 浏览器</h2><hr>
<p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：<br>解析 —— HTML，CSS，JS<br>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制  </p>
<p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。<br>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。<br>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：<br>一个地址栏<br>后退和前进按<br>书签选项<br>刷新和停止按钮<br>主页按钮  </p>
<h3 id="浏览器高层架构"><a href="#浏览器高层架构" class="headerlink" title="浏览器高层架构"></a>浏览器高层架构</h3><p>组成浏览器的组件有：  </p>
<h5 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h5><p>用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分  </p>
<h5 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h5><p>浏览器引擎负责让 UI 和渲染引擎协调工作  </p>
<h5 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h5><p>渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上  </p>
<h5 id="网络组件"><a href="#网络组件" class="headerlink" title="网络组件"></a>网络组件</h5><p>网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</p>
<h5 id="UI后端"><a href="#UI后端" class="headerlink" title="UI后端"></a>UI后端</h5><p>UI后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</p>
<h5 id="Javascript引擎"><a href="#Javascript引擎" class="headerlink" title="Javascript引擎"></a>Javascript引擎</h5><p>Javascript引擎用于解析和执行 Javascript 代码</p>
<h5 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h5><p>数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</p>
<h3 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h3><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。<br>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。<br>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。  </p>
<h4 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h4><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:<br>语言本身的“宽容”特性<br>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们<br>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容<br>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>
<h5 id="解析结束之后"><a href="#解析结束之后" class="headerlink" title="解析结束之后"></a>解析结束之后</h5><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。<br>此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。<br>注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。  </p>
<h3 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h3><p>根据 CSS词法和句法 分析CSS文件,以及style标签包含的内容以及 style 属性的值<br>每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象<br>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</p>
<h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><p>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值<br>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度<br>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度<br>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度<br>使用上面的计算结果构建每个节点的坐标<br>当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算<br>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层<br>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制<br>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量<br>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</p>
<blockquote>
<p>GPU 渲染<br>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU<br>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</p>
</blockquote>
<h3 id="Window-Server-后期渲染与用户引发的处理"><a href="#Window-Server-后期渲染与用户引发的处理" class="headerlink" title="Window Server 后期渲染与用户引发的处理"></a>Window Server 后期渲染与用户引发的处理</h3><p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Baidu主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>
<h2 id="0x0A-总结"><a href="#0x0A-总结" class="headerlink" title="0x0A 总结"></a>0x0A 总结</h2><hr>
<p>总的来讲，当我们在浏览器地址栏输入 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a> 并按下回车后，一共发生了以下八项内容：  </p>
<p>[1]硬件/操作系统级，处理用户按下回车键<br>[2]解析URL<br>[3]DNS查询，解析域名，将域名解析为IP地址<br>[4]ARP广播，根据IP地址来解析MAC地址<br>[5]分别从应用层到传输层、网络层和数据链路层分别加入各个层的头部封装为包<br>[6]进行三次握手后，客户端与服务器建立连接<br>[7]客服务器向客户端返回数据，浏览器接收到数据<br>[8]浏览器开始渲染页面  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://su29029.github.io/2020/08/28/%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5www-baidu-com%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%EF%BC%8C%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" data-id="ckedou6hf0039yvty2b916s3j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c%E8%AF%AD%E8%A8%80/">c语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/web%E5%AE%89%E5%85%A8/">web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/web%E5%BC%80%E5%8F%91/">web开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/web%E5%AE%89%E5%85%A8/">web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows%E7%BC%96%E7%A8%8B/">windows编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c%E8%AF%AD%E8%A8%80/" rel="tag">c语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E5%AE%89%E5%85%A8/" rel="tag">web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows%E7%BC%96%E7%A8%8B/" rel="tag">windows编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/c%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">c语言</a> <a href="/tags/web%E5%AE%89%E5%85%A8/" style="font-size: 20px;">web安全</a> <a href="/tags/web%E5%BC%80%E5%8F%91/" style="font-size: 15px;">web开发</a> <a href="/tags/windows%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">windows编程</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络编程</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">软件工程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/28/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-1-1-2-3%E7%BB%84/">洛谷刷题记录(1)(1,2,3组)</a>
          </li>
        
          <li>
            <a href="/2020/08/28/ctfshow%E8%90%8C%E6%96%B0%E8%AE%A1%E5%88%92%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">ctfshow萌新计划刷题记录</a>
          </li>
        
          <li>
            <a href="/2020/08/28/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%951/">buu刷题记录1</a>
          </li>
        
          <li>
            <a href="/2020/08/28/csrf-ssrf-session%E4%BC%AA%E9%80%A0/">csrf&amp;ssrf&amp;session伪造</a>
          </li>
        
          <li>
            <a href="/2020/08/28/xxe%E9%97%AE%E9%A2%98/">xxe问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>